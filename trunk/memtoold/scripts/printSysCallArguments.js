if(HAVE_GLOBAL_PARAMS){
	eval("params="+PARAMS)
	var sys_call_nr = params["sys_call_nr"] //int
	var arg0 = params["rdi"] //hex string
	var arg1 = params["rsi"] //hex string
	var arg2 = params["rdx"] //hex string
	var arg3 = params["r10"] //hex string
	var arg4 = params["r8"] //hex string
	var arg5 = params["r9"] //hex string
	var userPGD = params["cr3"] // hex string
	
	if(typeof(arg0) == "undefined") print("rdi undefined")
	if(typeof(arg1) == "undefined") print("r2i undefined")
	if(typeof(arg2) == "undefined") print("rdx undefined")
	if(typeof(arg3) == "undefined") print("r10 undefined")
	if(typeof(arg4) == "undefined") print("r8 undefined")
	if(typeof(arg5) == "undefined") print("r9 undefined")
	if(typeof(userPGD) == "undefined") print("cr3 undefined")
}else{
	print("no parameters specified")
}


/*from entry_64.S
 432 * Register setup:
 433 * rax  system call number
 434 * rdi  arg0
 435 * rcx  return address for syscall/sysret, C arg3
 436 * rsi  arg1
 437 * rdx  arg2
 438 * r10  arg3    (--> moved to rcx for C)
 439 * r8   arg4
 440 * r9   arg5
 441 * r11  eflags for syscall/sysret, temporary for C
 442 * r12-r15,rbp,rbx saved by C code, not touched.
 443 *
 444 * Interrupts are off on entry.
 445 * Only called from user space.
 446 *
 447 * XXX  if we had a free scratch register we could save the RSP into the stack frame
 448 *      and report it properly in ps. Unfortunately we haven't.
 449 *
 450 * When user can change the frames always force IRET. That is because
 451 * it deals with uncanonical addresses better. SYSRET has trouble
 452 * with them due to bugs in both AMD and Intel CPUs.
 453 */



// dict generated by gen_syscall_memtool_script.py, available in diekmann's git
include("lib_syscalls_2.6.32-x64.js")

include("lib_getCurrent_2.6.32-x64.js")

//workaround to create an instance
//EMPTY_INSTANCE should signal that we do not care about the symbol
EMPTY_INSTANCE="init_task"


function main(){
	var tmpInst = new Instance(EMPTY_INSTANCE)
	tmpInst.ChangeType("uint64_t")
	tmpInst.SetAddress("0")
	
	print(SysCalls[sys_call_nr]["sys_name"]+": "+SysCalls[sys_call_nr]["signature"])
	
	
	var i
	for(i=0; i < SysCalls[sys_call_nr]["argc"]; i++){
		var arg = SysCalls[sys_call_nr]["arg"+i]
		
		// global parameter sys_call_arg is now the conetent of the register which contains the syscall parameter
		var sys_call_arg = eval("arg"+i) 
		
		line = "\t"
		
		var arg_name = arg["name"] == "" ? "?unknown?" : arg["name"]
		line += arg_name+": "
		tmpInstValid = false;
		if(!arg["isPtr"]){
			// treat argument as value in register, try to cast to specific type
			// and print it
			line += arg["type"]+": "
			
			tmpInst.SetAddress("0") // ignore addr
			try{
				tmpInst.ChangeType(arg["type"])
				tmpInstValid = true;
			}catch(e){
				line += "exception: "
				line += e
			}
		
			if(tmpInstValid){
				line += "0x"+sys_call_arg
			}
		}else{
			// treat argument as pointer, just print value
			line += arg["type"]+" "+arg["user_ptr"]+": 0x"+sys_call_arg
			
			//try to deref the value
			try{
				tmpInst.ChangeType(arg["type"])
				tmpInst.SetAddress(sys_call_arg)
				tmpInstValid = true;
			}catch(e){
				tmpInstValid = false;
				try{// give it another try with only the last part of the type
					type = arg["type"].split(" ")[1]
					tmpInst.ChangeType(type)
					tmpInstValid = true;
				}catch(e){
					//print(e)
				}
				if(!tmpInstValid){
					line += " cannot dereference: "
					line += e
				}
			}
			
			// this always returns false as we set the address to userSpace!
			// if this returns true, we try to access kernel memory!
			if(tmpInst.IsAccessible()){
				line += " cannot dereference: Memory address points to kernel space!"
			}else if(tmpInstValid){
				try{
					line += " -> "+tmpInst.derefUserLand(userPGD)
				}catch(e){
					line += " cannot dereference: "
					line += e
				}
			}//else{
			//	line += "unknown type "+arg["type"]
			//}
		}
		print(line)
		
	}
}

try{
	main()
}catch(e){
	print("Exception in main():")
	print(e)
}
