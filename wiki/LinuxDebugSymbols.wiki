#summary Generating and parsing debugging symbols for Linux
#labels Phase-Usage

= Linux Debugging Symbols =

<wiki:toc max_depth="2" />

= Introduction =

The foundation of !InSight's ability to extract kernel objects out of physical memory are the debugging symbols as well as the pre-processed source code of the Linux kernel being analyzed. Both data need to be generated by the compiler and parsed by !InSight prior to any analysis.

= Generating Debugging Symbols and Pre-Processed Source Code =

In order to create the debugging symbols and pre-process the source code for a Linux kernel, the kernel image of the system *being analyzed* must be re-compiled with
  * debugging symbol generation turned on and
  * the C compiler set to the `gcc_pp` script that comes along with !InSight. 

If you intend to inspect a system running inside of a virtual machine, follow the instructions below from *within* the virtual machine. 

In addition, this process requires a lot of disk space, typically more than 10GB. For a virtual machine environment, you might consider to dedicate a separate virtual disk to the machine that is used exclusively for this purpose. This keeps the primary disk image of the guest much smaller and easier to handle.

*Note:* The creation of debugging symbols does neither influence the semantics nor the performance of the resulting kernel image!

== Debian and Ubuntu Guests ==

Debian and derived distributions such as Ubuntu come with a handy tool called `make-kpkg` that creates custom kernel packages. These packages integrate the new kernel seamlessly into the system and is the preferred way of compiling the kernel.

We provide an additional helper script
[https://code.google.com/p/insight-vmi/source/browse/trunk/tools/make-debug-kpkg make-debug-kpkg] that fetches the source of the running kernel, prepares it for debugging symbol generation, compiles it, and creates the kernel packages utilizing `make-kpkg`. You can find this script in the directory [https://code.google.com/p/insight-vmi/source/browse/trunk/tools/ trunk/tools] of the !InSight source or in `/usr/share/insight/tools` if you installed the `insight-daemon` package.  Execute this script from within the directory you want the source to be built *within the guest*, for example:

{{{
cd /usr/src && sudo /path/to/make-debug-kpkg
}}}

Install the generated packages using `dpkg` (the exact package names might differ for your distribution):

{{{
sudo dpkg -i \
    ./linux-image-*-dbg*.deb \
    ./linux-headers-*-dbg*.deb
}}}

You are now ready to reboot your machine into the new kernel.

== Other Linux Guests ==

Unpack the source code of the running kernel and change to its directory. Most Linux distributions provide means to obtain the source code of the distribution's kernel including all patches and additions. Consult the manual of your package manager on how to do this.

Start by creating a backup copy of the original `Makefile`:

{{{
cp -v Makefile Makefile.orig
}}}

Now add the compiler switches for enabling debugging symbols to the appropriate variables and append the string "`-dbg`" to the kernel version:

{{{
sed \
    -e 's@^\(CFLAGS_KERNEL\s*=\)@\1 -g @' \
    -e 's@^\(AFLAGS_KERNEL\s*=\)@\1 -gdwarf-2 @' \
    -e 's@^\(EXTRAVERSION\s*=\)\s*\([^ ]*\)\s*$@\1 \2-dbg@' \
    Makefile.orig > Makefile
}}}

To build the kernel with the exact same settings as the distribution maintainers used, just copy over the configuration file of the running kernel:

{{{
cp -v /boot/config-$(uname -r) .config
}}}

Now the kernel is ready to be built:

{{{
make modules bzImage
}}}

Install the resulting kernel:

{{{
sudo make modules_install &&
sudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-$(uname -r)-dbg &&
sudo cp -v System.map /boot/System.map-$(uname -r)-dbg &&
sudo cp -v .config /boot/config-$(uname -r)-dbg &&
}}}

*Warning:* Your kernel might require an initial RAM disk to load some modules in order to mount the root file system! If this is the case, such a file must be generated as file `/boot/initrd-$(uname -r)-dbg`. As each Linux distribution implements its own way of creating such `initrd` files, we will not describe this process here. *The kernel image might not be boot-able without a corresponding `initrd` file!*

Now edit your bootloader's configuration files (most likely `/boot/grub/menu.lst`) and add a new entry for the new kernel image based on the entry for the currently running kernel and reboot your system to the new kernel.

= Parsing Debugging Symbols =

Once the debugging symbols are available, !InSight needs to parse them to build its internal type database. This step is necessary only once and takes several minutes to complete. !InSight requires the following information to parse the debugging symbols:

  * path to the object dump file of the kernel
  * path to the `System.map` file of the kernel
  * path to the configured header files of the kernel

There are two ways how these files can be passed to !InSight:

  # The preferred method is to make the path to the *kernel source directory* available that was previously used to compile the kernel. In that case, !InSight will use the following data from this directory:
    * `System.map` file
    * extracting debugging symbols from the `vmlinux` file on the fly using the `objdump` utility
    * `.config` file
    * using the module build system to extract version specific constants
  # If a more user controllable way is desired, the path to the *`System.map` file*, the *object dump file*, and the *configured kernel headers* can be specified. Here, !InSight will use the following data:
    * `System.map` file as specified
    * _uncompressed_ object dump file as specified (created by the user with `objdump -W vmlinux > file`)
    * `.config` file from the specified kernel headers directory
    * using the module build system to extract version specific constants from the specified kernel headers

If the inspected kernel runs inside of a virtual machine, both of these steps can be performed either inside of the virtual machine, in which case !InSight needs to be compiled for that machine, or from the host system. In the latter case, the required files need to be [#Copying_the_Kernel_Headers copied over to the host system], or the disk image of the virtual machine needs to be [#Mounting_a_Virtual_Disk_Image mounted on the host system].

== Copying the Kernel Headers ==

If an SSH server is running inside of the virtual machine, the easiest way to copy the required files is to utilize `tar` over the SSH connection. This ensures that all symbolic links in the kernel source or headers directory are correctly restored. The following command does this trick (replace `vmhost, `OVER`, `KVER`, and all directories accordingly):

{{{
mkdir /tmp/vmfiles
OVER=2.6.38-10-generic-dbg
KVER=2.6.38.7-10-generic-dbg
ssh vmhost tar -C / -cf - \
    /usr/src/objdump-$OVER.lzma \
    /boot/System.map-$KVER \
    /usr/src/linux-headers-$KVER \
    | tar -C /tmp/vmfiles -xvf -
}}}

Now you have all required files and directories available on the host for [#Parsing_Symbols_with_InSight processing by InSight].

== Mounting a Virtual Disk Image ==

When using KVM or QEMU as the hypervisor, the disks in raw format can be directly mounted into the host's file system. To check if a file, for example `image-file.bin`, is in raw format, the `qemu-img` utility can be used:

{{{
qemu-img info image-file.bin
}}}

This tool is also able to convert an existing image into raw format. Details can be found in the corresponding man page.

*Warning: Power down the virtual machine before mounting the disk image!*

Mounting a raw disk image works in conjunction with the kernels loop block devices. Therefore the module `loop` must be loaded first, if it is not directly built into the kernel:

{{{
sudo modprobe loop
}}}

Now find an unused loop device and link it with the image file, but with an offset of 63*512 bytes. The offset will skip the hold virtual hard disk's management sectors:

{{{
sudo su -                   # become root
DEV=$(losetup --find) &&
losetup -o $((63 * 512)) $DEV image-file.bin &&
mount -o ro $DEV /mnt
}}}

You should now be able to browse the guest's file system when entering the `/mnt` directory. When !InSight is done with [#Parsing_Symbols_with_InSight parsing the debugging symbols], unmount the disk image again:

{{{
umount $DEV && losetup -d $DEV
}}}

== Parsing Symbols with !InSight ==

When either the build directory of the kernel source tree or the `System.map`, object dump, and kernel headers directory have been made available, !InSight is ready to parse the debugging symbols. During this step, !InSight compiles a tiny helper program to extract some information from the kernel sources. This requires the `stdio.h` header to be available, so make sure the `libc6-dev` package is installed on your host system before you continue.

Start `insightd` in interactive mode by not supplying any parameters. The shell syntax to parse the debugging symbols is either
<pre>  symbols parse <kernel_src></pre>
or
<pre>  symbols parse <objdump> <System.map> <kernel_headers></pre>
depending on the available data. 

*Note:* In the second case, the `<objdump>` file mentioned above must *not* be compressed! The non-compressed object dump does not have a `.bz2` or `.lzma` extension.

While the symbols are being processed, the progress is being displayed. At the end of the operation, you will see a short statistic about the resulting type database:

{{{
>>> symbols parse /mnt/vdisk/usr/src/linux-2.6-2.6.32/
Successfully parsed the memory specifications in 3 sec
Parsing 24778305 lines (1338583706 bytes) finished.
Statistics:
  | No. of types:                   41786         
  | No. of types by name:           32298         
  | No. of types by ID:           1370492         
  | No. of types by hash:           40150         
  | No of "struct list_head":         484         
  | No of "struct hlist_node":         46         
  | No. of variables:               24508         
  | No. of variables by ID:         24508         
  | No. of variables by name:       24508         
  | Empty structs replaced:           186         
  | Empty structs remaining:           94         
  `-------------------------------------------
Parsing finish in 5 min 22 sec (76809 lines per second).
}}}

== Storing Symbols Database ==

!InSight needs to parse the debugging symbols only once, they can then be stored in a custom data format for future use. The corresponding command is:

<pre>  symbols store <dest_file></pre>

For example:

{{{
>>> symbols store insight-2.6-2.6.32.ksym
Writing symbols finished (18948166 bytes written).
Writing of 18948166 bytes finished in 4 sec (3982380 byte/s).
}}}

With this final step, !InSight is prepared to be used for memory analysis for this kernel version. To learn more about how !InSight can be used, you might be interested in reading about the [InSightShell InSight shell] and the [ScriptingEngine JavaScript engine].