# Linux Debugging Symbols #



# Introduction #

The foundation of InSight's ability to extract kernel objects out of physical memory are the debugging symbols as well as the pre-processed source code of the Linux kernel being analyzed. Both data need to be generated by the compiler and parsed by InSight prior to any analysis.

# Generating Debugging Symbols and Pre-Processed Source Code #

In order to create the debugging symbols and pre-process the source code for a Linux kernel, the kernel image of the system **being analyzed** must be re-compiled with
  * debugging symbol generation turned on and
  * the C compiler set to `gcc_pp`.

The latter is a Perl script that comes along with InSight. It stores the pre-processed source files in a separate directory during compilation that are parsed later on.

If you intend to inspect a system running inside of a virtual machine, follow the instructions to compile the kernel from **within the virtual machine**. Also note that this process requires a lot of disk space, typically more than 10GB. For a virtual machine environment, you might consider to add another virtual disk to the machine that is used exclusively for this purpose. This keeps the root disk image of the guest much smaller and easier to handle.

## Debian and Ubuntu Guests ##

Debian and derived distributions such as Ubuntu come with a handy tool called `make-kpkg` that creates custom kernel packages. These packages integrate the new kernel image seamlessly into the system.

We provide an additional helper script
[make-debug-kpkg](https://code.google.com/p/insight-vmi/source/browse/trunk/tools/make-debug-kpkg) that fetches the source of the running kernel, prepares it for debugging symbol generation, compiles it, and creates the kernel packages utilizing `make-kpkg`. You can find this script in the directory [trunk/tools](https://code.google.com/p/insight-vmi/source/browse/trunk/tools/) of the InSight source or in `/usr/share/insight/tools` if you installed the `insight-daemon` package.

The `make-debug-kpkg` tool depends on the [gcc\_pp](https://code.google.com/p/insight-vmi/source/browse/trunk/tools/gcc_pp) script which can be found in the same directory as `make-debug-kpkg` script.  If not yet installed, copy both scripts to the same directory of the **guest** file system, for example `/usr/local/bin/`.  Now you are ready to execute `make-debug-kpkg` from within the directory you want the source to be built, for example:

```
cd /usr/src && sudo /path/to/make-debug-kpkg
```

Install the generated packages using `dpkg` (the exact package names might differ for your distribution):

```
sudo dpkg -i \
    ./linux-image-*-dbg*.deb \
    ./linux-headers-*-dbg*.deb
```

You are now ready to reboot your machine into the new kernel.

## Other Linux Guests ##

First make sure the [gcc\_pp](https://code.google.com/p/insight-vmi/source/browse/trunk/tools/gcc_pp) script is executable within the guest.  You can find this script in the directory [trunk/tools](https://code.google.com/p/insight-vmi/source/browse/trunk/tools/) of the InSight source directory.  Copy that file to the guest, for example to the `/usr/local/bin/` directory.

Most Linux distributions provide means to obtain the source code of the distribution's kernel including all patches and additions. Consult the manual of your package manager on how to do this.

Now unpack the source code of the running kernel and change to its directory. To prepare for compilation of the kernel, start by creating a backup copy of the original `Makefile`:

```
cp -v Makefile Makefile.orig
```

Add the compiler switches for enabling debugging symbols and to the appropriate variables, replace the `gcc` compiler with `gcc_pp`, and append the string "`-dbg`" to the kernel version:

```
sed \
    -e 's@^\(CFLAGS_KERNEL\s*=\)@\1 -g @' \
    -e 's@^\(AFLAGS_KERNEL\s*=\)@\1 -gdwarf-2 @' \
    -e 's@^\(CC\s*=\).*gcc\s*$@\1 gcc_pp@' \
    -e 's@^\(EXTRAVERSION\s*=\)\s*\([^ ]*\)\s*$@\1 \2-dbg@' \
    Makefile.orig > Makefile
```

To build the kernel with the exact same settings as the distribution maintainers used, just copy over the configuration file of the running kernel:

```
cp -v /boot/config-$(uname -r) .config
```

Now the kernel is ready to be built:

```
make modules bzImage
```

Install the resulting kernel:

```
sudo make modules_install &&
sudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-$(uname -r)-dbg &&
sudo cp -v System.map /boot/System.map-$(uname -r)-dbg &&
sudo cp -v .config /boot/config-$(uname -r)-dbg &&
```

Revert the changes made to the `Makefile` to avoid problems during the parsing phase later on:

```
cp -v Makefile.orig Makefile
```

Finally, update your bootloader's configuration files to include the new kernel.  Most distributions provide tools for this purpose, typically called `update-grub` or `update-bootloader`. Please consult your distro's manual for details.

**Warning:** Your kernel might require an **initial RAM disk** to load some modules in order to mount the root file system! If this is the case, such a file must be generated as file `/boot/initrd-$(uname -r)-dbg`. As each Linux distribution implements its own way of creating such `initrd` files, we will not describe this process here. **The kernel image might not be bootable without a corresponding `initrd` file!**

# Giving InSight Access to the Data #

In order to parse the debugging symbols and source files, InSight requires access to the whole kernel source directory that was used to compile the kernel in the previous step.  More precisely, the following resources in that directory are required:
  * the `System.map` file
  * the `vmlinux` kernel image, non-stripped
  * the `.config` file
  * the configured and ready-to-use module build system to extract version specific constants
  * the pre-processed sources in the `__PP__` directory

The symbol parsing can be performed either inside of the virtual machine, in which case InSight needs to be compiled for that guest, or inside the host system. In the latter case, the required files need to be [copied over to the host system](#Copying_the_Kernel_Headers.md), or the disk image of the virtual machine needs to be [mounted on the host system](#Mounting_a_Virtual_Disk_Image.md).

## Copying the Source Directory Using SSH ##

If an SSH server is running inside of the virtual machine, the easiest way to copy the required files is to utilize `tar` over the SSH connection. This ensures that all symbolic links in the kernel source or headers directory are correctly restored. The following command does this trick (replace `vmhost` with the IP address of the guest, `/usr/src/` the previously specified source directory, and `linux-x.y.z` with the kernel version accordingly):

```
mkdir -pv /tmp/vmfiles &&
ssh vmhost tar -C /usr/src/ -cf - linux-x.y.z | tar -C /tmp/vmfiles -xvf -
```

Now you have all required files and directories available on the host for [processing by InSight](#Parsing_Symbols_with_InSight.md).

## Mounting a Virtual Disk Image ##

When using KVM or QEMU as the hypervisor, the disks in raw format can be directly mounted into the host's file system. To check if a file, for example `disk-image.bin`, is in raw format, the `qemu-img` utility can be used:

```
qemu-img info disk-image.bin
```

Mounting a raw disk image works in conjunction with the kernels loop block devices and requires a certain offset to be calculated. InSight comes with a convenient helper script called `mount-img` that automates this process. Again, it is located either in the `tools` directory of the source package of InSight, or you may find it in `/usr/share/insight/tools` if you installed the provided packages.

**Warning: Unmount the disk image within the virtual machine before mounting the disk image on the host!**

Mounting the disk image with this script is easy:

```
sudo mkdir -pv /mnt/vdisk &&
sudo /path/to/mount-img disk-image.bin /mnt/vdisk
```

You should see a message similar to the following:

```
Image sucessfully mounted:                                                                          
/dev/loop0 on /mnt/vdisk type ext3 (ro)
```

# Parsing the Debugging Symbols and Source Files #

With the build directory of the kernel source tree available, InSight is readyl to parse them to build its internal type database. This step is necessary only once and takes several minutes to complete.

During this step, InSight compiles a tiny helper program to extract some information from the kernel sources. This requires the `stdio.h` header to be available, so make sure the `libc6-dev` package is installed on your host system before you continue. In case you intend to parse the symbols of a **32 bit guest** on a **64 bit host**, you additionally need the 32 bit version of this library and headers. For Debian and Ubuntu systems, this requires the package `libc6-dev-i386` to be installed as well.

When all prerequisites are met, start `insightd` in interactive mode by not supplying any parameters. The shell syntax to parse the debugging symbols is:
```
symbols parse <kernel_src_dir>
```

If `gcc_pp` was enabled as `gcc` replacement during kernel compilation, you will be asked if the source should be parsed as well:

```
>>> symbols parse /mnt/vdisk/usr/src/linux-2.6-2.6.32/
Directory with pre-processed source files detected. Process them as well? [Y/n] _
```

Choose "yes" to leverage the full potential of InSight. While the symbols are being processed, the progress is being displayed. At the end of the operation, you will see some statistics about the resulting type database:

```
Successfully parsed the memory specifications in 3 sec
Parsing debugging symbols with 24778305 lines (1338583672 bytes) finished in 6 min 28 sec.
Statistics:
  | No. of types:                   42605         
  | No. of types by name:           31768         
  | No. of types by ID:           1369658         
  | No. of types by hash:           42605         
  | No. of variables:               24508         
  | No. of variables by ID:         24508         
  | No. of variables by name:       24508         
  | Empty structs replaced:           186         
  | Empty structs remaining:           94         
  `-------------------------------------------
Parsing finish in 5 min 22 sec (76809 lines per second).
Parsed 1135/1135 files in 17 min 59 sec.
Statistics:
  | Type changes of struct members:       2181
  | Type changes of variables:             233
  | Total type changes:                   2414
  | Types copied:                          685
  | Ambigues types:                       1469
  `-------------------------------------------
```

# Storing Symbol Database #

InSight stores the type database in a custom format, so the debugging symbols and source files need to be parsed only once. The command for storing the database is:

<pre>  symbols store <dest_file></pre>

For example:

```
>>> symbols store insight-2.6-2.6.32.ksym
Writing symbols finished (18948166 bytes written).
Writing of 18948166 bytes finished in 4 sec (3982380 byte/s).
```

With this final step, InSight is prepared to be used for memory analysis for this kernel version. To learn more about how InSight can be used, continue reading about the [InSight shell](InSightShell.md) and the [JavaScript engine](ScriptingEngine.md).