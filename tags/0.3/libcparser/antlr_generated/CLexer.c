/** \file
 *  This C source file was generated by $ANTLR version 3.0.1
 *
 *     -  From the grammar source file : src/C.g
 *     -                            On : 2011-11-15 16:54:36
 *     -                 for the lexer : CLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
*/
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "CLexer.h"
/* ----------------------------------------- */


/** String literals used by CLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x5F, 0x5F, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x74, 0x79, 0x70, 0x65, 0x64, 0x65, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x5F, 0x5F, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x5F, 0x5F, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x63, 0x6F, 0x6E, 0x73, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x5F, 0x5F, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x7C, 0x7C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x26, 0x26,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x21, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x3C, 0x3C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x3E, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x5F, 0x5F, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x6F, 0x66, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x74, 0x79, 0x70, 0x65, 0x73, 0x5F, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x74, 0x69, 0x62, 0x6C, 0x65, 0x5F, 0x70,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x73, 0x74, 0x61, 0x74, 0x69, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x61, 0x75, 0x74, 0x6F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x69, 0x6E, 0x6C, 0x69, 0x6E, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x5F, 0x5F, 0x69, 0x6E, 0x6C, 0x69, 0x6E, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x5F, 0x5F, 0x69, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x76, 0x6F, 0x69, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x63, 0x68, 0x61, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x73, 0x68, 0x6F, 0x72, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x69, 0x6E, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x6C, 0x6F, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x66, 0x6C, 0x6F, 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x64, 0x6F, 0x75, 0x62, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x5F, 0x5F, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x75, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x5F, 0x42, 0x6F, 0x6F, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x76, 0x61, 0x5F, 0x6C, 0x69, 0x73, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x74, 0x79, 0x70, 0x65, 0x6F, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x5F, 0x5F, 0x74, 0x79, 0x70, 0x65, 0x6F, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x5F, 0x5F, 0x74, 0x79, 0x70, 0x65, 0x6F, 0x66, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x73, 0x74, 0x72, 0x75, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x75, 0x6E, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x65, 0x6E, 0x75, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x76, 0x6F, 0x6C, 0x61, 0x74, 0x69, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x5F, 0x5F, 0x76, 0x6F, 0x6C, 0x61, 0x74, 0x69, 0x6C, 0x65, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x2E, 0x2E, 0x2E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x2B, 0x2B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x2D, 0x2D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x63, 0x68, 0x6F, 0x6F, 0x73, 0x65, 0x5F, 0x65, 0x78, 0x70, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x5F, 0x70,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x5F, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x5F, 0x61, 0x64, 0x64, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x5F, 0x73, 0x69, 0x7A, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x6F, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x5F, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x76, 0x61, 0x5F, 0x61, 0x72, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x76, 0x61, 0x5F, 0x63, 0x6F, 0x70, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x76, 0x61, 0x5F, 0x65, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x5F, 0x5F, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x69, 0x6E, 0x5F, 0x76, 0x61, 0x5F, 0x73, 0x74, 0x61, 0x72, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x2D, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x2A, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x2F, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x25, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x2B, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_65[]  = { 0x2D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_66[]  = { 0x3C, 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_67[]  = { 0x3E, 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_68[]  = { 0x26, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_69[]  = { 0x5E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_70[]  = { 0x7C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_71[]  = { 0x63, 0x61, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_72[]  = { 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_73[]  = { 0x5F, 0x5F, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_74[]  = { 0x69, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_75[]  = { 0x65, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_76[]  = { 0x73, 0x77, 0x69, 0x74, 0x63, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_77[]  = { 0x77, 0x68, 0x69, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_78[]  = { 0x64, 0x6F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_79[]  = { 0x66, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_80[]  = { 0x67, 0x6F, 0x74, 0x6F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_81[]  = { 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x6E, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_82[]  = { 0x62, 0x72, 0x65, 0x61, 0x6B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_83[]  = { 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_84[]  = { 0x61, 0x73, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_85[]  = { 0x5F, 0x5F, 0x61, 0x73, 0x6D, 0x5F, 0x5F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_86[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_87[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_88[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};


/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pCLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pCLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pCLexer_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always refering to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritence.
 */
 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define	    RULEMEMO				RECOGNIZER->ruleMemo
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXER->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXER->token
#define	    HASFAILED()				(RECOGNIZER->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			RECOGNIZER->backtracking
#define	    FAILEDFLAG				RECOGNIZER->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		INDEX()					INPUT->istream->index(INPUT->istream)
#define		SEEK(n)					INPUT->istream->seek(INPUT->istream, n)
#define	    EOF_TOKEN				&(LEXER->tokSource->eofToken)
#define	    HASEXCEPTION()			(RECOGNIZER->error == ANTLR3_TRUE)
#define	    EXCEPTION				RECOGNIZER->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					INPUT->istream->mark(INPUT->istream)
#define	    REWIND(m)				INPUT->istream->rewind(INPUT->istream, m)
#define	    REWINDLAST()			INPUT->istream->rewindLast(INPUT->istream)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXER->text = str
#define		USER1					LEXER->user1
#define		USER2					LEXER->user2
#define		USER3					LEXER->user3
#define		CUSTOM					LEXER->custom

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers wiht a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))					\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;										\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);	\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE void	mT25    (pCLexer ctx);
static ANTLR3_INLINE void	mT26    (pCLexer ctx);
static ANTLR3_INLINE void	mT27    (pCLexer ctx);
static ANTLR3_INLINE void	mT28    (pCLexer ctx);
static ANTLR3_INLINE void	mT29    (pCLexer ctx);
static ANTLR3_INLINE void	mT30    (pCLexer ctx);
static ANTLR3_INLINE void	mT31    (pCLexer ctx);
static ANTLR3_INLINE void	mT32    (pCLexer ctx);
static ANTLR3_INLINE void	mT33    (pCLexer ctx);
static ANTLR3_INLINE void	mT34    (pCLexer ctx);
static ANTLR3_INLINE void	mT35    (pCLexer ctx);
static ANTLR3_INLINE void	mT36    (pCLexer ctx);
static ANTLR3_INLINE void	mT37    (pCLexer ctx);
static ANTLR3_INLINE void	mT38    (pCLexer ctx);
static ANTLR3_INLINE void	mT39    (pCLexer ctx);
static ANTLR3_INLINE void	mT40    (pCLexer ctx);
static ANTLR3_INLINE void	mT41    (pCLexer ctx);
static ANTLR3_INLINE void	mT42    (pCLexer ctx);
static ANTLR3_INLINE void	mT43    (pCLexer ctx);
static ANTLR3_INLINE void	mT44    (pCLexer ctx);
static ANTLR3_INLINE void	mT45    (pCLexer ctx);
static ANTLR3_INLINE void	mT46    (pCLexer ctx);
static ANTLR3_INLINE void	mT47    (pCLexer ctx);
static ANTLR3_INLINE void	mT48    (pCLexer ctx);
static ANTLR3_INLINE void	mT49    (pCLexer ctx);
static ANTLR3_INLINE void	mT50    (pCLexer ctx);
static ANTLR3_INLINE void	mT51    (pCLexer ctx);
static ANTLR3_INLINE void	mT52    (pCLexer ctx);
static ANTLR3_INLINE void	mT53    (pCLexer ctx);
static ANTLR3_INLINE void	mT54    (pCLexer ctx);
static ANTLR3_INLINE void	mT55    (pCLexer ctx);
static ANTLR3_INLINE void	mT56    (pCLexer ctx);
static ANTLR3_INLINE void	mT57    (pCLexer ctx);
static ANTLR3_INLINE void	mT58    (pCLexer ctx);
static ANTLR3_INLINE void	mT59    (pCLexer ctx);
static ANTLR3_INLINE void	mT60    (pCLexer ctx);
static ANTLR3_INLINE void	mT61    (pCLexer ctx);
static ANTLR3_INLINE void	mT62    (pCLexer ctx);
static ANTLR3_INLINE void	mT63    (pCLexer ctx);
static ANTLR3_INLINE void	mT64    (pCLexer ctx);
static ANTLR3_INLINE void	mT65    (pCLexer ctx);
static ANTLR3_INLINE void	mT66    (pCLexer ctx);
static ANTLR3_INLINE void	mT67    (pCLexer ctx);
static ANTLR3_INLINE void	mT68    (pCLexer ctx);
static ANTLR3_INLINE void	mT69    (pCLexer ctx);
static ANTLR3_INLINE void	mT70    (pCLexer ctx);
static ANTLR3_INLINE void	mT71    (pCLexer ctx);
static ANTLR3_INLINE void	mT72    (pCLexer ctx);
static ANTLR3_INLINE void	mT73    (pCLexer ctx);
static ANTLR3_INLINE void	mT74    (pCLexer ctx);
static ANTLR3_INLINE void	mT75    (pCLexer ctx);
static ANTLR3_INLINE void	mT76    (pCLexer ctx);
static ANTLR3_INLINE void	mT77    (pCLexer ctx);
static ANTLR3_INLINE void	mT78    (pCLexer ctx);
static ANTLR3_INLINE void	mT79    (pCLexer ctx);
static ANTLR3_INLINE void	mT80    (pCLexer ctx);
static ANTLR3_INLINE void	mT81    (pCLexer ctx);
static ANTLR3_INLINE void	mT82    (pCLexer ctx);
static ANTLR3_INLINE void	mT83    (pCLexer ctx);
static ANTLR3_INLINE void	mT84    (pCLexer ctx);
static ANTLR3_INLINE void	mT85    (pCLexer ctx);
static ANTLR3_INLINE void	mT86    (pCLexer ctx);
static ANTLR3_INLINE void	mT87    (pCLexer ctx);
static ANTLR3_INLINE void	mT88    (pCLexer ctx);
static ANTLR3_INLINE void	mT89    (pCLexer ctx);
static ANTLR3_INLINE void	mT90    (pCLexer ctx);
static ANTLR3_INLINE void	mT91    (pCLexer ctx);
static ANTLR3_INLINE void	mT92    (pCLexer ctx);
static ANTLR3_INLINE void	mT93    (pCLexer ctx);
static ANTLR3_INLINE void	mT94    (pCLexer ctx);
static ANTLR3_INLINE void	mT95    (pCLexer ctx);
static ANTLR3_INLINE void	mT96    (pCLexer ctx);
static ANTLR3_INLINE void	mT97    (pCLexer ctx);
static ANTLR3_INLINE void	mT98    (pCLexer ctx);
static ANTLR3_INLINE void	mT99    (pCLexer ctx);
static ANTLR3_INLINE void	mT100    (pCLexer ctx);
static ANTLR3_INLINE void	mT101    (pCLexer ctx);
static ANTLR3_INLINE void	mT102    (pCLexer ctx);
static ANTLR3_INLINE void	mT103    (pCLexer ctx);
static ANTLR3_INLINE void	mT104    (pCLexer ctx);
static ANTLR3_INLINE void	mT105    (pCLexer ctx);
static ANTLR3_INLINE void	mT106    (pCLexer ctx);
static ANTLR3_INLINE void	mT107    (pCLexer ctx);
static ANTLR3_INLINE void	mT108    (pCLexer ctx);
static ANTLR3_INLINE void	mT109    (pCLexer ctx);
static ANTLR3_INLINE void	mT110    (pCLexer ctx);
static ANTLR3_INLINE void	mT111    (pCLexer ctx);
static ANTLR3_INLINE void	mT112    (pCLexer ctx);
static ANTLR3_INLINE void	mT113    (pCLexer ctx);
static ANTLR3_INLINE void	mT114    (pCLexer ctx);
static ANTLR3_INLINE void	mT115    (pCLexer ctx);
static ANTLR3_INLINE void	mT116    (pCLexer ctx);
static ANTLR3_INLINE void	mT117    (pCLexer ctx);
static ANTLR3_INLINE void	mT118    (pCLexer ctx);
static ANTLR3_INLINE void	mT119    (pCLexer ctx);
static ANTLR3_INLINE void	mT120    (pCLexer ctx);
static ANTLR3_INLINE void	mT121    (pCLexer ctx);
static ANTLR3_INLINE void	mT122    (pCLexer ctx);
static ANTLR3_INLINE void	mT123    (pCLexer ctx);
static ANTLR3_INLINE void	mT124    (pCLexer ctx);
static ANTLR3_INLINE void	mT125    (pCLexer ctx);
static ANTLR3_INLINE void	mT126    (pCLexer ctx);
static ANTLR3_INLINE void	mT127    (pCLexer ctx);
static ANTLR3_INLINE void	mT128    (pCLexer ctx);
static ANTLR3_INLINE void	mT129    (pCLexer ctx);
static ANTLR3_INLINE void	mT130    (pCLexer ctx);
static ANTLR3_INLINE void	mT131    (pCLexer ctx);
static ANTLR3_INLINE void	mT132    (pCLexer ctx);
static ANTLR3_INLINE void	mT133    (pCLexer ctx);
static ANTLR3_INLINE void	mIDENTIFIER    (pCLexer ctx);
static ANTLR3_INLINE void	mLETTER    (pCLexer ctx);
static ANTLR3_INLINE void	mCHARACTER_LITERAL    (pCLexer ctx);
static ANTLR3_INLINE void	mSTRING_LITERAL    (pCLexer ctx);
static ANTLR3_INLINE void	mSTRING_GUTS    (pCLexer ctx);
static ANTLR3_INLINE void	mHEX_LITERAL    (pCLexer ctx);
static ANTLR3_INLINE void	mDECIMAL_LITERAL    (pCLexer ctx);
static ANTLR3_INLINE void	mOCTAL_LITERAL    (pCLexer ctx);
static ANTLR3_INLINE void	mHexDigit    (pCLexer ctx);
static ANTLR3_INLINE void	mIntegerTypeSuffix    (pCLexer ctx);
static ANTLR3_INLINE void	mFLOATING_POINT_LITERAL    (pCLexer ctx);
static ANTLR3_INLINE void	mExponent    (pCLexer ctx);
static ANTLR3_INLINE void	mFloatTypeSuffix    (pCLexer ctx);
static ANTLR3_INLINE void	mEscapeSequence    (pCLexer ctx);
static ANTLR3_INLINE void	mOctalEscape    (pCLexer ctx);
static ANTLR3_INLINE void	mHexEscape    (pCLexer ctx);
static ANTLR3_INLINE void	mUnicodeEscape    (pCLexer ctx);
static ANTLR3_INLINE void	mWS    (pCLexer ctx);
static ANTLR3_INLINE void	mCOMMENT    (pCLexer ctx);
static ANTLR3_INLINE void	mLINE_COMMENT    (pCLexer ctx);
static ANTLR3_INLINE void	mLINE_COMMAND    (pCLexer ctx);
static ANTLR3_INLINE void	mTokens    (pCLexer ctx);
static void	CLexerFree(pCLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
CLexerFree  (pCLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the gramar file that generated this code
 */
static unsigned char fileName[] = "src/C.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static unsigned char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called CLexer
 *
 * \param[in] instream Pointer to an initialized input stream
 *
 * \return 
 *     - Success pCLexer initialized for the lex start
 *     - Fail (pCLexer)(ANTLR3_ERR_NOMEM)
 */
ANTLR3_API pCLexer CLexerNew         (pANTLR3_INPUT_STREAM     instream)
{
    pCLexer lexCtx; /* Context structure we will build and return   */

    lexCtx = (pCLexer) ANTLR3_MALLOC(sizeof(CLexer));

    if  (lexCtx == NULL)
    {
        /* Failed to allocate memory for lexer context */
        return  (pCLexer)ANTLR3_ERR_NOMEM;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in CLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    lexCtx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream);

    /* Check that we allocated the memory correctly
     */
    if	(lexCtx->pLexer == (pANTLR3_LEXER)ANTLR3_ERR_NOMEM)
    {
	ANTLR3_FREE(lexCtx);
	return  (pCLexer)ANTLR3_ERR_NOMEM;
    }
    /* Install the implementation of our CLexer interface
     */
    lexCtx->mT25	= mT25;
    lexCtx->mT26	= mT26;
    lexCtx->mT27	= mT27;
    lexCtx->mT28	= mT28;
    lexCtx->mT29	= mT29;
    lexCtx->mT30	= mT30;
    lexCtx->mT31	= mT31;
    lexCtx->mT32	= mT32;
    lexCtx->mT33	= mT33;
    lexCtx->mT34	= mT34;
    lexCtx->mT35	= mT35;
    lexCtx->mT36	= mT36;
    lexCtx->mT37	= mT37;
    lexCtx->mT38	= mT38;
    lexCtx->mT39	= mT39;
    lexCtx->mT40	= mT40;
    lexCtx->mT41	= mT41;
    lexCtx->mT42	= mT42;
    lexCtx->mT43	= mT43;
    lexCtx->mT44	= mT44;
    lexCtx->mT45	= mT45;
    lexCtx->mT46	= mT46;
    lexCtx->mT47	= mT47;
    lexCtx->mT48	= mT48;
    lexCtx->mT49	= mT49;
    lexCtx->mT50	= mT50;
    lexCtx->mT51	= mT51;
    lexCtx->mT52	= mT52;
    lexCtx->mT53	= mT53;
    lexCtx->mT54	= mT54;
    lexCtx->mT55	= mT55;
    lexCtx->mT56	= mT56;
    lexCtx->mT57	= mT57;
    lexCtx->mT58	= mT58;
    lexCtx->mT59	= mT59;
    lexCtx->mT60	= mT60;
    lexCtx->mT61	= mT61;
    lexCtx->mT62	= mT62;
    lexCtx->mT63	= mT63;
    lexCtx->mT64	= mT64;
    lexCtx->mT65	= mT65;
    lexCtx->mT66	= mT66;
    lexCtx->mT67	= mT67;
    lexCtx->mT68	= mT68;
    lexCtx->mT69	= mT69;
    lexCtx->mT70	= mT70;
    lexCtx->mT71	= mT71;
    lexCtx->mT72	= mT72;
    lexCtx->mT73	= mT73;
    lexCtx->mT74	= mT74;
    lexCtx->mT75	= mT75;
    lexCtx->mT76	= mT76;
    lexCtx->mT77	= mT77;
    lexCtx->mT78	= mT78;
    lexCtx->mT79	= mT79;
    lexCtx->mT80	= mT80;
    lexCtx->mT81	= mT81;
    lexCtx->mT82	= mT82;
    lexCtx->mT83	= mT83;
    lexCtx->mT84	= mT84;
    lexCtx->mT85	= mT85;
    lexCtx->mT86	= mT86;
    lexCtx->mT87	= mT87;
    lexCtx->mT88	= mT88;
    lexCtx->mT89	= mT89;
    lexCtx->mT90	= mT90;
    lexCtx->mT91	= mT91;
    lexCtx->mT92	= mT92;
    lexCtx->mT93	= mT93;
    lexCtx->mT94	= mT94;
    lexCtx->mT95	= mT95;
    lexCtx->mT96	= mT96;
    lexCtx->mT97	= mT97;
    lexCtx->mT98	= mT98;
    lexCtx->mT99	= mT99;
    lexCtx->mT100	= mT100;
    lexCtx->mT101	= mT101;
    lexCtx->mT102	= mT102;
    lexCtx->mT103	= mT103;
    lexCtx->mT104	= mT104;
    lexCtx->mT105	= mT105;
    lexCtx->mT106	= mT106;
    lexCtx->mT107	= mT107;
    lexCtx->mT108	= mT108;
    lexCtx->mT109	= mT109;
    lexCtx->mT110	= mT110;
    lexCtx->mT111	= mT111;
    lexCtx->mT112	= mT112;
    lexCtx->mT113	= mT113;
    lexCtx->mT114	= mT114;
    lexCtx->mT115	= mT115;
    lexCtx->mT116	= mT116;
    lexCtx->mT117	= mT117;
    lexCtx->mT118	= mT118;
    lexCtx->mT119	= mT119;
    lexCtx->mT120	= mT120;
    lexCtx->mT121	= mT121;
    lexCtx->mT122	= mT122;
    lexCtx->mT123	= mT123;
    lexCtx->mT124	= mT124;
    lexCtx->mT125	= mT125;
    lexCtx->mT126	= mT126;
    lexCtx->mT127	= mT127;
    lexCtx->mT128	= mT128;
    lexCtx->mT129	= mT129;
    lexCtx->mT130	= mT130;
    lexCtx->mT131	= mT131;
    lexCtx->mT132	= mT132;
    lexCtx->mT133	= mT133;
    lexCtx->mIDENTIFIER	= mIDENTIFIER;
    lexCtx->mLETTER	= mLETTER;
    lexCtx->mCHARACTER_LITERAL	= mCHARACTER_LITERAL;
    lexCtx->mSTRING_LITERAL	= mSTRING_LITERAL;
    lexCtx->mSTRING_GUTS	= mSTRING_GUTS;
    lexCtx->mHEX_LITERAL	= mHEX_LITERAL;
    lexCtx->mDECIMAL_LITERAL	= mDECIMAL_LITERAL;
    lexCtx->mOCTAL_LITERAL	= mOCTAL_LITERAL;
    lexCtx->mHexDigit	= mHexDigit;
    lexCtx->mIntegerTypeSuffix	= mIntegerTypeSuffix;
    lexCtx->mFLOATING_POINT_LITERAL	= mFLOATING_POINT_LITERAL;
    lexCtx->mExponent	= mExponent;
    lexCtx->mFloatTypeSuffix	= mFloatTypeSuffix;
    lexCtx->mEscapeSequence	= mEscapeSequence;
    lexCtx->mOctalEscape	= mOctalEscape;
    lexCtx->mHexEscape	= mHexEscape;
    lexCtx->mUnicodeEscape	= mUnicodeEscape;
    lexCtx->mWS	= mWS;
    lexCtx->mCOMMENT	= mCOMMENT;
    lexCtx->mLINE_COMMENT	= mLINE_COMMENT;
    lexCtx->mLINE_COMMAND	= mLINE_COMMAND;
    lexCtx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    lexCtx->pLexer->ctx	    = lexCtx;
    
    /** Install the token matching function
     */
    lexCtx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    lexCtx->getGrammarFileName	= getGrammarFileName;
    lexCtx->free		= CLexerFree;
    
	 
    /* Return the newly built lexer to the caller
     */
    return  lexCtx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    2461:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? ( FloatTypeSuffix )? | '.' ( '0' .. '9' )+ ( Exponent )? ( FloatTypeSuffix )? | ( '0' .. '9' )+ ( Exponent ( FloatTypeSuffix )? | FloatTypeSuffix ) );
 */
static const ANTLR3_INT32 dfa26_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa26_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa26_min[5] =
    {
	46, 46, -1, -1, -1
    };
static const ANTLR3_INT32 dfa26_max[5] =
    {
	57, 102, -1, -1, -1
    };
static const ANTLR3_INT32 dfa26_accept[5] =
    {
	-1, -1, 2, 1, 3
    };
static const ANTLR3_INT32 dfa26_special[5] =
    {	
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa26_T_empty	    NULL

static const ANTLR3_INT32 dfa26_T0[] =
    {
	3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 4, 4
    };static const ANTLR3_INT32 dfa26_T1[] =
    {
	2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa26_transitions[] =
{
    dfa26_T1, dfa26_T0, dfa26_T_empty, dfa26_T_empty, dfa26_T_empty	
};


/* Declare tracking structure for Cyclic DFA 26
 */
static
ANTLR3_CYCLIC_DFA cdfa26
    =	{
	    26,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"2461:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? ( FloatTypeSuffix )? | '.' ( '0' .. '9' )+ ( Exponent )? ( FloatTypeSuffix )? | ( '0' .. '9' )+ ( Exponent ( FloatTypeSuffix )? | FloatTypeSuffix ) );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa26_eot,	    /* EOT table			    */
	    dfa26_eof,	    /* EOF table			    */
	    dfa26_min,	    /* Minimum tokens for each state    */
	    dfa26_max,	    /* Maximum tokens for each state    */
	    dfa26_accept,	/* Accept table			    */
	    dfa26_special,	/* Special transition states	    */
	    dfa26_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 26
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T25 | T26 | T27 | T28 | T29 | T30 | T31 | T32 | T33 | T34 | T35 | T36 | T37 | T38 | T39 | T40 | T41 | T42 | T43 | T44 | T45 | T46 | T47 | T48 | T49 | T50 | T51 | T52 | T53 | T54 | T55 | T56 | T57 | T58 | T59 | T60 | T61 | T62 | T63 | T64 | T65 | T66 | T67 | T68 | T69 | T70 | T71 | T72 | T73 | T74 | T75 | T76 | T77 | T78 | T79 | T80 | T81 | T82 | T83 | T84 | T85 | T86 | T87 | T88 | T89 | T90 | T91 | T92 | T93 | T94 | T95 | T96 | T97 | T98 | T99 | T100 | T101 | T102 | T103 | T104 | T105 | T106 | T107 | T108 | T109 | T110 | T111 | T112 | T113 | T114 | T115 | T116 | T117 | T118 | T119 | T120 | T121 | T122 | T123 | T124 | T125 | T126 | T127 | T128 | T129 | T130 | T131 | T132 | T133 | IDENTIFIER | CHARACTER_LITERAL | STRING_LITERAL | HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOATING_POINT_LITERAL | WS | COMMENT | LINE_COMMENT | LINE_COMMAND );
 */
static const ANTLR3_INT32 dfa38_eot[508] =
    {
	-1, 41, 41, -1, -1, 52, -1, -1, 41, -1, -1, 58, 61, 63, 65, 68, 71, 74, 
	78, 80, 84, 86, 41, 93, 41, 41, 41, 41, 41, 41, 41, 41, 41, -1, -1, -1, 
	-1, -1, 41, 41, 41, -1, -1, -1, 114, 114, -1, -1, 41, 41, 41, -1, -1, 41, 
	41, 41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, 133, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 
	41, -1, -1, -1, 41, 41, 41, 41, 41, 41, 41, 149, 41, 41, 41, 41, 156, 41, 
	41, 41, 41, 41, -1, 163, -1, 114, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	191, 41, 41, 41, 195, -1, 41, 41, 41, 41, 200, 41, -1, 41, 41, 41, 41, 
	41, 41, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 222, 41, 
	41, 225, 41, 41, 41, 41, 41, 41, 41, 233, 234, 235, -1, 41, 41, 41, -1, 
	41, 240, 241, 41, -1, 41, 41, 41, 41, 41, 248, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 261, 41, 41, -1, 264, 41, -1, 41, 41, 41, 41, 270, 
	41, 41, -1, -1, -1, 41, 41, 41, 41, -1, -1, 277, 41, 41, 280, 41, 282, 
	-1, 283, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, -1, 41, 296, -1, 41, 
	298, 299, 300, 301, -1, 302, 303, 41, 305, 306, 41, -1, 308, 41, -1, 41, 
	-1, -1, 41, 41, 41, 41, 41, 316, 41, 41, 41, 41, 41, 322, -1, 41, -1, -1, 
	-1, -1, -1, -1, 41, -1, -1, 41, -1, 326, 41, 41, 41, 331, 333, 41, -1, 
	41, 41, 41, 41, 41, -1, 340, 341, 342, -1, 343, 41, 41, 41, -1, 41, -1, 
	41, 41, 41, 41, 352, 353, -1, -1, -1, -1, 41, 41, 362, 363, 41, 41, 366, 
	41, -1, -1, 41, 41, 41, 41, 41, 41, 41, 41, -1, -1, 379, 380, -1, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 392, 41, -1, -1, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, -1, 409, 410, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, -1, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 443, 41, 445, 41, 41, 41, 449, 41, 41, 41, 41, 
	41, 41, 456, -1, 457, -1, 41, 41, 41, -1, 41, 41, 41, 41, 41, 466, -1, 
	-1, 41, 41, 469, 41, 41, 472, 41, 41, -1, 41, 41, -1, 41, 41, -1, 41, 480, 
	41, 41, 41, 41, 485, -1, 41, 41, 41, 489, -1, 41, 41, 41, -1, 41, 41, 41, 
	41, 497, 41, 41, -1, 41, 41, 41, 41, 41, 505, 41, -1, 507, -1
    };
static const ANTLR3_INT32 dfa38_eof[508] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa38_min[508] =
    {
	9, 66, 121, -1, -1, 61, -1, -1, 97, -1, -1, 61, 38, 61, 61, 60, 61, 43, 
	45, 61, 42, 61, 104, 46, 108, 115, 101, 102, 111, 111, 108, 101, 110, -1, 
	-1, -1, -1, -1, 104, 111, 114, -1, -1, -1, 46, 46, -1, -1, 97, 111, 112, 
	-1, -1, 97, 110, 115, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, 
	61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	103, 97, 111, 105, -1, -1, -1, 116, 117, 115, 116, 109, 103, 108, 36, 105, 
	110, 111, 114, 36, 102, 105, 105, 116, 101, -1, 46, -1, 46, 117, 111, 121, 
	110, 108, 105, 120, 97, 111, 111, 101, 114, 115, 101, -1, -1, -1, -1, 101, 
	110, 117, 116, 114, 116, 101, 109, 101, 111, 36, 105, 117, 105, 36, -1, 
	97, 100, 103, 97, 36, 98, -1, 97, 111, 105, 108, 111, 97, -1, 105, 108, 
	112, 108, 116, 109, 105, 103, 116, 98, 110, 108, 100, 36, 116, 105, 36, 
	111, 101, 99, 105, 116, 99, 114, 36, 36, 36, -1, 115, 114, 110, -1, 116, 
	36, 36, 116, -1, 108, 117, 110, 103, 101, 36, 107, 108, 97, 101, 105, 114, 
	95, 103, 110, 101, 101, 115, 36, 101, 102, -1, 36, 110, -1, 102, 100, 116, 
	99, 36, 104, 110, -1, -1, -1, 116, 110, 101, 105, -1, -1, 36, 101, 108, 
	36, 110, 36, -1, 36, 116, 116, 111, 110, 105, 95, 110, 101, 110, 108, 116, 
	-1, 102, 36, -1, 117, 36, 36, 36, 36, -1, 36, 36, 101, 36, 36, 108, -1, 
	36, 116, -1, 101, -1, -1, 105, 105, 102, 101, 98, 36, 111, 100, 115, 95, 
	95, 36, -1, 101, -1, -1, -1, -1, -1, -1, 114, -1, -1, 101, -1, 36, 100, 
	110, 108, 36, 36, 117, -1, 102, 95, 105, 95, 95, -1, 36, 36, 36, -1, 36, 
	95, 101, 95, -1, 95, -1, 116, 95, 95, 111, 36, 36, -1, -1, -1, -1, 99, 
	95, 36, 36, 101, 95, 36, 110, -1, -1, 104, 97, 121, 101, 114, 120, 98, 
	95, -1, -1, 36, 36, -1, 95, 111, 110, 95, 112, 116, 101, 112, 106, 102, 
	36, 95, -1, -1, 95, 111, 115, 97, 101, 117, 102, 101, 114, 101, 115, -1, 
	36, 36, 115, 116, 116, 111, 114, 105, 110, 115, 114, 101, 99, 97, 99, 101, 
	-1, -1, 101, 97, 97, 112, 103, 115, 100, 95, 110, 116, 116, 99, 116, 116, 
	95, 110, 114, 121, 36, 116, 36, 99, 95, 99, 36, 116, 95, 111, 101, 116, 
	116, 36, -1, 36, -1, 111, 97, 104, -1, 95, 115, 102, 120, 95, 36, -1, -1, 
	109, 100, 36, 114, 105, 36, 112, 112, -1, 112, 100, -1, 101, 122, -1, 114, 
	36, 97, 114, 116, 101, 36, -1, 116, 101, 117, 36, -1, 105, 115, 114, -1, 
	98, 115, 110, 108, 36, 95, 101, -1, 97, 95, 100, 112, 100, 36, 114, -1, 
	36, -1
    };
static const ANTLR3_INT32 dfa38_max[508] =
    {
	126, 95, 121, -1, -1, 61, -1, -1, 111, -1, -1, 124, 61, 61, 61, 61, 62, 
	61, 62, 61, 61, 61, 119, 57, 120, 117, 101, 110, 111, 111, 111, 111, 110, 
	-1, -1, -1, -1, -1, 104, 111, 114, -1, -1, -1, 120, 102, -1, -1, 118, 111, 
	112, -1, -1, 97, 110, 115, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, 
	-1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 122, 114, 111, 105, -1, -1, -1, 116, 117, 115, 116, 109, 116, 116, 
	122, 108, 110, 111, 114, 122, 102, 115, 105, 116, 101, -1, 102, -1, 102, 
	117, 111, 121, 110, 116, 105, 120, 97, 111, 111, 101, 114, 116, 101, -1, 
	-1, -1, -1, 101, 110, 117, 116, 114, 116, 101, 109, 101, 111, 122, 105, 
	117, 105, 122, -1, 97, 100, 103, 97, 122, 98, -1, 97, 111, 105, 108, 111, 
	97, -1, 105, 108, 112, 108, 116, 109, 105, 103, 116, 98, 110, 108, 111, 
	122, 116, 105, 122, 111, 101, 99, 105, 116, 99, 114, 122, 122, 122, -1, 
	115, 114, 110, -1, 116, 122, 122, 116, -1, 108, 117, 110, 103, 101, 122, 
	107, 108, 97, 101, 105, 114, 95, 103, 110, 101, 101, 115, 122, 101, 102, 
	-1, 122, 110, -1, 102, 100, 116, 99, 122, 104, 110, -1, -1, -1, 116, 110, 
	101, 105, -1, -1, 122, 101, 108, 122, 110, 122, -1, 122, 116, 116, 111, 
	110, 105, 95, 110, 101, 110, 108, 116, -1, 102, 122, -1, 117, 122, 122, 
	122, 122, -1, 122, 122, 101, 122, 122, 108, -1, 122, 116, -1, 101, -1, 
	-1, 105, 105, 102, 101, 98, 122, 111, 100, 115, 95, 95, 122, -1, 101, -1, 
	-1, -1, -1, -1, -1, 114, -1, -1, 101, -1, 122, 100, 110, 108, 122, 122, 
	117, -1, 102, 95, 105, 95, 95, -1, 122, 122, 122, -1, 122, 95, 101, 95, 
	-1, 95, -1, 116, 95, 95, 111, 122, 122, -1, -1, -1, -1, 118, 95, 122, 122, 
	101, 95, 122, 110, -1, -1, 111, 97, 121, 101, 114, 120, 102, 95, -1, -1, 
	122, 122, -1, 95, 111, 110, 95, 112, 116, 101, 116, 106, 102, 122, 95, 
	-1, -1, 95, 111, 115, 115, 101, 117, 102, 101, 114, 101, 115, -1, 122, 
	122, 115, 116, 116, 111, 114, 105, 110, 115, 114, 101, 99, 97, 99, 101, 
	-1, -1, 101, 97, 97, 112, 103, 115, 100, 95, 110, 116, 116, 99, 116, 116, 
	95, 110, 114, 121, 122, 116, 122, 99, 95, 99, 122, 116, 95, 111, 101, 116, 
	116, 122, -1, 122, -1, 111, 97, 104, -1, 95, 115, 102, 120, 95, 122, -1, 
	-1, 109, 100, 122, 114, 105, 122, 112, 112, -1, 112, 100, -1, 101, 122, 
	-1, 114, 122, 97, 114, 116, 101, 122, -1, 116, 101, 117, 122, -1, 105, 
	115, 114, -1, 98, 115, 110, 108, 122, 95, 101, -1, 97, 95, 100, 112, 100, 
	122, 114, -1, 122, -1
    };
static const ANTLR3_INT32 dfa38_accept[508] =
    {
	-1, -1, -1, 3, 4, -1, 8, 9, -1, 12, 13, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, 59, 65, 66, 
	83, -1, -1, -1, 110, 111, 112, -1, -1, 117, 120, -1, -1, -1, 19, 5, -1, 
	-1, -1, 94, 14, 16, 92, 15, 18, 93, 17, 20, 84, -1, 23, 21, -1, 24, 22, 
	68, 88, 27, 69, 82, 89, 28, 85, 29, 118, 119, 86, 30, 87, 31, -1, -1, -1, 
	-1, 67, 116, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 113, -1, 114, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 90, 25, 91, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 98, -1, -1, -1, -1, -1, -1, 102, -1, -1, -1, -1, -1, 
	-1, 115, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, 46, -1, -1, 
	-1, -1, 103, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 44, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, 62, 
	99, 38, -1, -1, -1, -1, 43, 47, -1, -1, -1, -1, -1, -1, 104, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, 10, -1, -1, -1, -1, -1, 
	45, -1, -1, -1, -1, -1, -1, 48, -1, -1, 61, -1, 101, 106, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 55, -1, 32, 50, 60, 37, 100, 36, -1, 107, 
	40, -1, 49, -1, -1, -1, -1, -1, -1, -1, 109, -1, -1, -1, -1, -1, 2, -1, 
	-1, -1, 96, -1, -1, -1, -1, 56, -1, 41, -1, -1, -1, -1, -1, -1, 105, 39, 
	63, 52, -1, -1, -1, -1, -1, -1, -1, -1, 97, 11, -1, -1, -1, -1, -1, -1, 
	-1, -1, 57, 42, -1, -1, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 7, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 78, -1, 80, -1, -1, -1, 72, -1, 
	-1, -1, -1, -1, -1, 79, 54, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, 
	76, -1, -1, 75, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, 70, -1, 
	-1, -1, 74, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, -1, -1, -1, -1, -1, 
	34, -1, 73
    };
static const ANTLR3_INT32 dfa38_special[508] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa38_T_empty	    NULL

static const ANTLR3_INT32 dfa38_T0[] =
    {
	41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, -1, -1, -1, -1, 41, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41
    };static const ANTLR3_INT32 dfa38_T1[] =
    {
	98, -1, 97
    };static const ANTLR3_INT32 dfa38_T2[] =
    {
	56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 57
    };static const ANTLR3_INT32 dfa38_T3[] =
    {
	339
    };static const ANTLR3_INT32 dfa38_T4[] =
    {
	218
    };static const ANTLR3_INT32 dfa38_T5[] =
    {
	260
    };static const ANTLR3_INT32 dfa38_T6[] =
    {
	294
    };static const ANTLR3_INT32 dfa38_T7[] =
    {
	321
    };static const ANTLR3_INT32 dfa38_T8[] =
    {
	89, 87, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, -1, 90
    };static const ANTLR3_INT32 dfa38_T9[] =
    {
	104, -1, -1, 105
    };static const ANTLR3_INT32 dfa38_T10[] =
    {
	103
    };static const ANTLR3_INT32 dfa38_T11[] =
    {
	178, 179
    };static const ANTLR3_INT32 dfa38_T12[] =
    {
	128
    };static const ANTLR3_INT32 dfa38_T13[] =
    {
	174
    };static const ANTLR3_INT32 dfa38_T14[] =
    {
	223
    };static const ANTLR3_INT32 dfa38_T15[] =
    {
	99
    };static const ANTLR3_INT32 dfa38_T16[] =
    {
	418
    };static const ANTLR3_INT32 dfa38_T17[] =
    {
	399, -1, 398, -1, 401, -1, -1, -1, -1, -1, -1, 400, -1, -1, -1, -1, -1, 
	-1, 397
    };static const ANTLR3_INT32 dfa38_T18[] =
    {
	402
    };static const ANTLR3_INT32 dfa38_T19[] =
    {
	446
    };static const ANTLR3_INT32 dfa38_T20[] =
    {
	432
    };static const ANTLR3_INT32 dfa38_T21[] =
    {
	384
    };static const ANTLR3_INT32 dfa38_T22[] =
    {
	385
    };static const ANTLR3_INT32 dfa38_T23[] =
    {
	371
    };static const ANTLR3_INT32 dfa38_T24[] =
    {
	490
    };static const ANTLR3_INT32 dfa38_T25[] =
    {
	486
    };static const ANTLR3_INT32 dfa38_T26[] =
    {
	496
    };static const ANTLR3_INT32 dfa38_T27[] =
    {
	493
    };static const ANTLR3_INT32 dfa38_T28[] =
    {
	467
    };static const ANTLR3_INT32 dfa38_T29[] =
    {
	458
    };static const ANTLR3_INT32 dfa38_T30[] =
    {
	481
    };static const ANTLR3_INT32 dfa38_T31[] =
    {
	475
    };static const ANTLR3_INT32 dfa38_T32[] =
    {
	499
    };static const ANTLR3_INT32 dfa38_T33[] =
    {
	501
    };static const ANTLR3_INT32 dfa38_T34[] =
    {
	503
    };static const ANTLR3_INT32 dfa38_T35[] =
    {
	140
    };static const ANTLR3_INT32 dfa38_T36[] =
    {
	187
    };static const ANTLR3_INT32 dfa38_T37[] =
    {
	232
    };static const ANTLR3_INT32 dfa38_T38[] =
    {
	272
    };static const ANTLR3_INT32 dfa38_T39[] =
    {
	370
    };static const ANTLR3_INT32 dfa38_T40[] =
    {
	266
    };static const ANTLR3_INT32 dfa38_T41[] =
    {
	226
    };static const ANTLR3_INT32 dfa38_T42[] =
    {
	181
    };static const ANTLR3_INT32 dfa38_T43[] =
    {
	354, -1, 359, -1, -1, -1, -1, -1, -1, -1, -1, -1, 360, 358, -1, 357, -1, 
	356, -1, 355
    };static const ANTLR3_INT32 dfa38_T44[] =
    {
	290
    };static const ANTLR3_INT32 dfa38_T45[] =
    {
	256
    };static const ANTLR3_INT32 dfa38_T46[] =
    {
	214
    };static const ANTLR3_INT32 dfa38_T47[] =
    {
	344
    };static const ANTLR3_INT32 dfa38_T48[] =
    {
	166
    };static const ANTLR3_INT32 dfa38_T49[] =
    {
	252
    };static const ANTLR3_INT32 dfa38_T50[] =
    {
	349
    };static const ANTLR3_INT32 dfa38_T51[] =
    {
	365
    };static const ANTLR3_INT32 dfa38_T52[] =
    {
	210
    };static const ANTLR3_INT32 dfa38_T53[] =
    {
	317
    };static const ANTLR3_INT32 dfa38_T54[] =
    {
	335
    };static const ANTLR3_INT32 dfa38_T55[] =
    {
	313
    };static const ANTLR3_INT32 dfa38_T56[] =
    {
	328
    };static const ANTLR3_INT32 dfa38_T57[] =
    {
	286
    };static const ANTLR3_INT32 dfa38_T58[] =
    {
	194
    };static const ANTLR3_INT32 dfa38_T59[] =
    {
	275
    };static const ANTLR3_INT32 dfa38_T60[] =
    {
	238
    };static const ANTLR3_INT32 dfa38_T61[] =
    {
	311
    };static const ANTLR3_INT32 dfa38_T62[] =
    {
	158, -1, -1, -1, -1, -1, -1, -1, -1, -1, 159
    };static const ANTLR3_INT32 dfa38_T63[] =
    {
	284
    };static const ANTLR3_INT32 dfa38_T64[] =
    {
	347
    };static const ANTLR3_INT32 dfa38_T65[] =
    {
	229
    };static const ANTLR3_INT32 dfa38_T66[] =
    {
	184
    };static const ANTLR3_INT32 dfa38_T67[] =
    {
	250
    };static const ANTLR3_INT32 dfa38_T68[] =
    {
	107, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106
    };static const ANTLR3_INT32 dfa38_T69[] =
    {
	269
    };static const ANTLR3_INT32 dfa38_T70[] =
    {
	190
    };static const ANTLR3_INT32 dfa38_T71[] =
    {
	143
    };static const ANTLR3_INT32 dfa38_T72[] =
    {
	192
    };static const ANTLR3_INT32 dfa38_T73[] =
    {
	208
    };static const ANTLR3_INT32 dfa38_T74[] =
    {
	60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 59
    };static const ANTLR3_INT32 dfa38_T75[] =
    {
	236
    };static const ANTLR3_INT32 dfa38_T76[] =
    {
	324
    };static const ANTLR3_INT32 dfa38_T77[] =
    {
	273
    };static const ANTLR3_INT32 dfa38_T78[] =
    {
	304
    };static const ANTLR3_INT32 dfa38_T79[] =
    {
	171
    };static const ANTLR3_INT32 dfa38_T80[] =
    {
	364
    };static const ANTLR3_INT32 dfa38_T81[] =
    {
	348
    };static const ANTLR3_INT32 dfa38_T82[] =
    {
	334
    };static const ANTLR3_INT32 dfa38_T83[] =
    {
	315
    };static const ANTLR3_INT32 dfa38_T84[] =
    {
	267
    };static const ANTLR3_INT32 dfa38_T85[] =
    {
	227
    };static const ANTLR3_INT32 dfa38_T86[] =
    {
	288
    };static const ANTLR3_INT32 dfa38_T87[] =
    {
	182
    };static const ANTLR3_INT32 dfa38_T88[] =
    {
	254
    };static const ANTLR3_INT32 dfa38_T89[] =
    {
	212
    };static const ANTLR3_INT32 dfa38_T90[] =
    {
	130
    };static const ANTLR3_INT32 dfa38_T91[] =
    {
	243
    };static const ANTLR3_INT32 dfa38_T92[] =
    {
	278
    };static const ANTLR3_INT32 dfa38_T93[] =
    {
	201
    };static const ANTLR3_INT32 dfa38_T94[] =
    {
	242
    };static const ANTLR3_INT32 dfa38_T95[] =
    {
	79
    };static const ANTLR3_INT32 dfa38_T96[] =
    {
	153
    };static const ANTLR3_INT32 dfa38_T97[] =
    {
	199
    };static const ANTLR3_INT32 dfa38_T98[] =
    {
	132
    };static const ANTLR3_INT32 dfa38_T99[] =
    {
	375, -1, -1, -1, 376
    };static const ANTLR3_INT32 dfa38_T100[] =
    {
	164
    };static const ANTLR3_INT32 dfa38_T101[] =
    {
	152
    };static const ANTLR3_INT32 dfa38_T102[] =
    {
	198
    };static const ANTLR3_INT32 dfa38_T103[] =
    {
	230
    };static const ANTLR3_INT32 dfa38_T104[] =
    {
	185
    };static const ANTLR3_INT32 dfa38_T105[] =
    {
	138
    };static const ANTLR3_INT32 dfa38_T106[] =
    {
	127
    };static const ANTLR3_INT32 dfa38_T107[] =
    {
	177
    };static const ANTLR3_INT32 dfa38_T108[] =
    {
	55, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, 54
    };static const ANTLR3_INT32 dfa38_T109[] =
    {
	46, 46, -1, 46, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 46, 14, 43, 47, 41, 21, 12, 42, 6, 7, 19, 17, 4, 18, 
	23, 20, 44, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 3, 15, 5, 16, 9, -1, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 35, -1, 36, 13, 1, -1, 25, 40, 8, 31, 24, 
	30, 39, 41, 27, 41, 41, 29, 41, 41, 41, 41, 41, 26, 22, 2, 32, 28, 38, 
	41, 41, 41, 33, 11, 34, 37
    };static const ANTLR3_INT32 dfa38_T110[] =
    {
	197
    };static const ANTLR3_INT32 dfa38_T111[] =
    {
	92, -1, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 92, 92, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 92, 92, 92
    };static const ANTLR3_INT32 dfa38_T112[] =
    {
	145, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 146
    };static const ANTLR3_INT32 dfa38_T113[] =
    {
	263
    };static const ANTLR3_INT32 dfa38_T114[] =
    {
	416
    };static const ANTLR3_INT32 dfa38_T115[] =
    {
	430
    };static const ANTLR3_INT32 dfa38_T116[] =
    {
	51
    };static const ANTLR3_INT32 dfa38_T117[] =
    {
	444
    };static const ANTLR3_INT32 dfa38_T118[] =
    {
	219
    };static const ANTLR3_INT32 dfa38_T119[] =
    {
	374
    };static const ANTLR3_INT32 dfa38_T120[] =
    {
	62
    };static const ANTLR3_INT32 dfa38_T121[] =
    {
	388, -1, -1, -1, 389
    };static const ANTLR3_INT32 dfa38_T122[] =
    {
	327
    };static const ANTLR3_INT32 dfa38_T123[] =
    {
	175
    };static const ANTLR3_INT32 dfa38_T124[] =
    {
	125
    };static const ANTLR3_INT32 dfa38_T125[] =
    {
	204
    };static const ANTLR3_INT32 dfa38_T126[] =
    {
	246
    };static const ANTLR3_INT32 dfa38_T127[] =
    {
	281
    };static const ANTLR3_INT32 dfa38_T128[] =
    {
	310
    };static const ANTLR3_INT32 dfa38_T129[] =
    {
	215
    };static const ANTLR3_INT32 dfa38_T130[] =
    {
	257
    };static const ANTLR3_INT32 dfa38_T131[] =
    {
	291
    };static const ANTLR3_INT32 dfa38_T132[] =
    {
	318
    };static const ANTLR3_INT32 dfa38_T133[] =
    {
	336
    };static const ANTLR3_INT32 dfa38_T134[] =
    {
	350
    };static const ANTLR3_INT32 dfa38_T135[] =
    {
	276
    };static const ANTLR3_INT32 dfa38_T136[] =
    {
	307
    };static const ANTLR3_INT32 dfa38_T137[] =
    {
	196
    };static const ANTLR3_INT32 dfa38_T138[] =
    {
	239
    };static const ANTLR3_INT32 dfa38_T139[] =
    {
	165
    };static const ANTLR3_INT32 dfa38_T140[] =
    {
	325
    };static const ANTLR3_INT32 dfa38_T141[] =
    {
	245
    };static const ANTLR3_INT32 dfa38_T142[] =
    {
	203
    };static const ANTLR3_INT32 dfa38_T143[] =
    {
	108
    };static const ANTLR3_INT32 dfa38_T144[] =
    {
	188
    };static const ANTLR3_INT32 dfa38_T145[] =
    {
	141
    };static const ANTLR3_INT32 dfa38_T146[] =
    {
	183
    };static const ANTLR3_INT32 dfa38_T147[] =
    {
	228
    };static const ANTLR3_INT32 dfa38_T148[] =
    {
	268
    };static const ANTLR3_INT32 dfa38_T149[] =
    {
	346
    };static const ANTLR3_INT32 dfa38_T150[] =
    {
	425
    };static const ANTLR3_INT32 dfa38_T151[] =
    {
	439
    };static const ANTLR3_INT32 dfa38_T152[] =
    {
	395
    };static const ANTLR3_INT32 dfa38_T153[] =
    {
	411
    };static const ANTLR3_INT32 dfa38_T154[] =
    {
	473
    };static const ANTLR3_INT32 dfa38_T155[] =
    {
	479
    };static const ANTLR3_INT32 dfa38_T156[] =
    {
	453
    };static const ANTLR3_INT32 dfa38_T157[] =
    {
	464
    };static const ANTLR3_INT32 dfa38_T158[] =
    {
	96, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, -1, 94
    };static const ANTLR3_INT32 dfa38_T159[] =
    {
	368, -1, -1, -1, -1, -1, -1, 369
    };static const ANTLR3_INT32 dfa38_T160[] =
    {
	382
    };static const ANTLR3_INT32 dfa38_T161[] =
    {
	102
    };static const ANTLR3_INT32 dfa38_T162[] =
    {
	251
    };static const ANTLR3_INT32 dfa38_T163[] =
    {
	209
    };static const ANTLR3_INT32 dfa38_T164[] =
    {
	312
    };static const ANTLR3_INT32 dfa38_T165[] =
    {
	285
    };static const ANTLR3_INT32 dfa38_T166[] =
    {
	345
    };static const ANTLR3_INT32 dfa38_T167[] =
    {
	329
    };static const ANTLR3_INT32 dfa38_T168[] =
    {
	377
    };static const ANTLR3_INT32 dfa38_T169[] =
    {
	361
    };static const ANTLR3_INT32 dfa38_T170[] =
    {
	85
    };static const ANTLR3_INT32 dfa38_T171[] =
    {
	431
    };static const ANTLR3_INT32 dfa38_T172[] =
    {
	417
    };static const ANTLR3_INT32 dfa38_T173[] =
    {
	442
    };static const ANTLR3_INT32 dfa38_T174[] =
    {
	428
    };static const ANTLR3_INT32 dfa38_T175[] =
    {
	414
    };static const ANTLR3_INT32 dfa38_T176[] =
    {
	135, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 134
    };static const ANTLR3_INT32 dfa38_T177[] =
    {
	41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, -1, -1, -1, -1, 378, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41
    };static const ANTLR3_INT32 dfa38_T178[] =
    {
	455
    };static const ANTLR3_INT32 dfa38_T179[] =
    {
	441
    };static const ANTLR3_INT32 dfa38_T180[] =
    {
	427
    };static const ANTLR3_INT32 dfa38_T181[] =
    {
	413
    };static const ANTLR3_INT32 dfa38_T182[] =
    {
	66, 67
    };static const ANTLR3_INT32 dfa38_T183[] =
    {
	476
    };static const ANTLR3_INT32 dfa38_T184[] =
    {
	482
    };static const ANTLR3_INT32 dfa38_T185[] =
    {
	459
    };static const ANTLR3_INT32 dfa38_T186[] =
    {
	468
    };static const ANTLR3_INT32 dfa38_T187[] =
    {
	41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, -1, -1, -1, -1, 330, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41
    };static const ANTLR3_INT32 dfa38_T188[] =
    {
	494
    };static const ANTLR3_INT32 dfa38_T189[] =
    {
	75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, 76
    };static const ANTLR3_INT32 dfa38_T190[] =
    {
	487
    };static const ANTLR3_INT32 dfa38_T191[] =
    {
	491
    };static const ANTLR3_INT32 dfa38_T192[] =
    {
	372
    };static const ANTLR3_INT32 dfa38_T193[] =
    {
	111
    };static const ANTLR3_INT32 dfa38_T194[] =
    {
	386
    };static const ANTLR3_INT32 dfa38_T195[] =
    {
	433
    };static const ANTLR3_INT32 dfa38_T196[] =
    {
	447
    };static const ANTLR3_INT32 dfa38_T197[] =
    {
	403
    };static const ANTLR3_INT32 dfa38_T198[] =
    {
	419
    };static const ANTLR3_INT32 dfa38_T199[] =
    {
	126
    };static const ANTLR3_INT32 dfa38_T200[] =
    {
	220, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 221
    };static const ANTLR3_INT32 dfa38_T201[] =
    {
	176
    };static const ANTLR3_INT32 dfa38_T202[] =
    {
	460
    };static const ANTLR3_INT32 dfa38_T203[] =
    {
	91, -1, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92
    };static const ANTLR3_INT32 dfa38_T204[] =
    {
	448
    };static const ANTLR3_INT32 dfa38_T205[] =
    {
	434
    };static const ANTLR3_INT32 dfa38_T206[] =
    {
	420
    };static const ANTLR3_INT32 dfa38_T207[] =
    {
	415
    };static const ANTLR3_INT32 dfa38_T208[] =
    {
	429
    };static const ANTLR3_INT32 dfa38_T209[] =
    {
	110
    };static const ANTLR3_INT32 dfa38_T210[] =
    {
	101, -1, -1, -1, -1, -1, -1, -1, 100
    };static const ANTLR3_INT32 dfa38_T211[] =
    {
	471
    };static const ANTLR3_INT32 dfa38_T212[] =
    {
	462
    };static const ANTLR3_INT32 dfa38_T213[] =
    {
	451
    };static const ANTLR3_INT32 dfa38_T214[] =
    {
	437
    };static const ANTLR3_INT32 dfa38_T215[] =
    {
	423
    };static const ANTLR3_INT32 dfa38_T216[] =
    {
	407
    };static const ANTLR3_INT32 dfa38_T217[] =
    {
	81, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 83
    };static const ANTLR3_INT32 dfa38_T218[] =
    {
	390
    };static const ANTLR3_INT32 dfa38_T219[] =
    {
	484
    };static const ANTLR3_INT32 dfa38_T220[] =
    {
	478
    };static const ANTLR3_INT32 dfa38_T221[] =
    {
	504
    };static const ANTLR3_INT32 dfa38_T222[] =
    {
	506
    };static const ANTLR3_INT32 dfa38_T223[] =
    {
	109
    };static const ANTLR3_INT32 dfa38_T224[] =
    {
	373
    };static const ANTLR3_INT32 dfa38_T225[] =
    {
	404
    };static const ANTLR3_INT32 dfa38_T226[] =
    {
	387
    };static const ANTLR3_INT32 dfa38_T227[] =
    {
	438
    };static const ANTLR3_INT32 dfa38_T228[] =
    {
	452
    };static const ANTLR3_INT32 dfa38_T229[] =
    {
	463
    };static const ANTLR3_INT32 dfa38_T230[] =
    {
	391
    };static const ANTLR3_INT32 dfa38_T231[] =
    {
	408
    };static const ANTLR3_INT32 dfa38_T232[] =
    {
	424
    };static const ANTLR3_INT32 dfa38_T233[] =
    {
	405
    };static const ANTLR3_INT32 dfa38_T234[] =
    {
	72, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	73
    };static const ANTLR3_INT32 dfa38_T235[] =
    {
	70, 69
    };static const ANTLR3_INT32 dfa38_T236[] =
    {
	383
    };static const ANTLR3_INT32 dfa38_T237[] =
    {
	426
    };static const ANTLR3_INT32 dfa38_T238[] =
    {
	440
    };static const ANTLR3_INT32 dfa38_T239[] =
    {
	396
    };static const ANTLR3_INT32 dfa38_T240[] =
    {
	412
    };static const ANTLR3_INT32 dfa38_T241[] =
    {
	474
    };static const ANTLR3_INT32 dfa38_T242[] =
    {
	454
    };static const ANTLR3_INT32 dfa38_T243[] =
    {
	465
    };static const ANTLR3_INT32 dfa38_T244[] =
    {
	422
    };static const ANTLR3_INT32 dfa38_T245[] =
    {
	406
    };static const ANTLR3_INT32 dfa38_T246[] =
    {
	450
    };static const ANTLR3_INT32 dfa38_T247[] =
    {
	436
    };static const ANTLR3_INT32 dfa38_T248[] =
    {
	470
    };static const ANTLR3_INT32 dfa38_T249[] =
    {
	461
    };static const ANTLR3_INT32 dfa38_T250[] =
    {
	483
    };static const ANTLR3_INT32 dfa38_T251[] =
    {
	477
    };static const ANTLR3_INT32 dfa38_T252[] =
    {
	492
    };static const ANTLR3_INT32 dfa38_T253[] =
    {
	488
    };static const ANTLR3_INT32 dfa38_T254[] =
    {
	498
    };static const ANTLR3_INT32 dfa38_T255[] =
    {
	495
    };static const ANTLR3_INT32 dfa38_T256[] =
    {
	502
    };static const ANTLR3_INT32 dfa38_T257[] =
    {
	500
    };static const ANTLR3_INT32 dfa38_T258[] =
    {
	421
    };static const ANTLR3_INT32 dfa38_T259[] =
    {
	435
    };static const ANTLR3_INT32 dfa38_T260[] =
    {
	92, -1, 113, 113, 113, 113, 113, 113, 113, 113, 92, 92, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 92, 92, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 112, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 92, 92, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 112
    };static const ANTLR3_INT32 dfa38_T261[] =
    {
	41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, -1, -1, -1, -1, 41, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 155, 41, 41, 41, 41, 41
    };static const ANTLR3_INT32 dfa38_T262[] =
    {
	151, -1, -1, 150
    };static const ANTLR3_INT32 dfa38_T263[] =
    {
	162
    };static const ANTLR3_INT32 dfa38_T264[] =
    {
	249
    };static const ANTLR3_INT32 dfa38_T265[] =
    {
	207
    };static const ANTLR3_INT32 dfa38_T266[] =
    {
	265
    };static const ANTLR3_INT32 dfa38_T267[] =
    {
	224
    };static const ANTLR3_INT32 dfa38_T268[] =
    {
	323
    };static const ANTLR3_INT32 dfa38_T269[] =
    {
	297
    };static const ANTLR3_INT32 dfa38_T270[] =
    {
	64
    };static const ANTLR3_INT32 dfa38_T271[] =
    {
	144
    };static const ANTLR3_INT32 dfa38_T272[] =
    {
	137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 136
    };static const ANTLR3_INT32 dfa38_T273[] =
    {
	170, -1, -1, -1, -1, -1, -1, 169, 168
    };static const ANTLR3_INT32 dfa38_T274[] =
    {
	50
    };static const ANTLR3_INT32 dfa38_T275[] =
    {
	193
    };static const ANTLR3_INT32 dfa38_T276[] =
    {
	237
    };static const ANTLR3_INT32 dfa38_T277[] =
    {
	274
    };static const ANTLR3_INT32 dfa38_T278[] =
    {
	289
    };static const ANTLR3_INT32 dfa38_T279[] =
    {
	255
    };static const ANTLR3_INT32 dfa38_T280[] =
    {
	213
    };static const ANTLR3_INT32 dfa38_T281[] =
    {
	173
    };static const ANTLR3_INT32 dfa38_T282[] =
    {
	217
    };static const ANTLR3_INT32 dfa38_T283[] =
    {
	259
    };static const ANTLR3_INT32 dfa38_T284[] =
    {
	293
    };static const ANTLR3_INT32 dfa38_T285[] =
    {
	320
    };static const ANTLR3_INT32 dfa38_T286[] =
    {
	338
    };static const ANTLR3_INT32 dfa38_T287[] =
    {
	189
    };static const ANTLR3_INT32 dfa38_T288[] =
    {
	142
    };static const ANTLR3_INT32 dfa38_T289[] =
    {
	139
    };static const ANTLR3_INT32 dfa38_T290[] =
    {
	231
    };static const ANTLR3_INT32 dfa38_T291[] =
    {
	186
    };static const ANTLR3_INT32 dfa38_T292[] =
    {
	160
    };static const ANTLR3_INT32 dfa38_T293[] =
    {
	205
    };static const ANTLR3_INT32 dfa38_T294[] =
    {
	271
    };static const ANTLR3_INT32 dfa38_T295[] =
    {
	247
    };static const ANTLR3_INT32 dfa38_T296[] =
    {
	92, -1, 113, 113, 113, 113, 113, 113, 113, 113, 92, 92, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 92, 92, 92, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 92, 92, 92
    };static const ANTLR3_INT32 dfa38_T297[] =
    {
	154
    };static const ANTLR3_INT32 dfa38_T298[] =
    {
	206
    };static const ANTLR3_INT32 dfa38_T299[] =
    {
	161
    };static const ANTLR3_INT32 dfa38_T300[] =
    {
	49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48
    };static const ANTLR3_INT32 dfa38_T301[] =
    {
	394
    };static const ANTLR3_INT32 dfa38_T302[] =
    {
	337
    };static const ANTLR3_INT32 dfa38_T303[] =
    {
	351
    };static const ANTLR3_INT32 dfa38_T304[] =
    {
	367
    };static const ANTLR3_INT32 dfa38_T305[] =
    {
	381
    };static const ANTLR3_INT32 dfa38_T306[] =
    {
	262
    };static const ANTLR3_INT32 dfa38_T307[] =
    {
	295
    };static const ANTLR3_INT32 dfa38_T308[] =
    {
	258
    };static const ANTLR3_INT32 dfa38_T309[] =
    {
	216
    };static const ANTLR3_INT32 dfa38_T310[] =
    {
	319
    };static const ANTLR3_INT32 dfa38_T311[] =
    {
	292
    };static const ANTLR3_INT32 dfa38_T312[] =
    {
	172
    };static const ANTLR3_INT32 dfa38_T313[] =
    {
	167
    };static const ANTLR3_INT32 dfa38_T314[] =
    {
	253
    };static const ANTLR3_INT32 dfa38_T315[] =
    {
	211
    };static const ANTLR3_INT32 dfa38_T316[] =
    {
	314
    };static const ANTLR3_INT32 dfa38_T317[] =
    {
	287
    };static const ANTLR3_INT32 dfa38_T318[] =
    {
	393
    };static const ANTLR3_INT32 dfa38_T319[] =
    {
	120, 116, 124, -1, 122, -1, -1, -1, 119, -1, -1, 123, -1, -1, -1, -1, -1, 
	-1, 121, 118, -1, 117
    };static const ANTLR3_INT32 dfa38_T320[] =
    {
	147, -1, -1, -1, -1, -1, -1, -1, 148
    };static const ANTLR3_INT32 dfa38_T321[] =
    {
	180
    };static const ANTLR3_INT32 dfa38_T322[] =
    {
	129
    };static const ANTLR3_INT32 dfa38_T323[] =
    {
	157
    };static const ANTLR3_INT32 dfa38_T324[] =
    {
	309
    };static const ANTLR3_INT32 dfa38_T325[] =
    {
	279
    };static const ANTLR3_INT32 dfa38_T326[] =
    {
	244
    };static const ANTLR3_INT32 dfa38_T327[] =
    {
	41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, -1, -1, -1, -1, -1, -1, -1, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, -1, -1, -1, -1, 332, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 
	41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41
    };static const ANTLR3_INT32 dfa38_T328[] =
    {
	202
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa38_transitions[] =
{
    dfa38_T109, dfa38_T300, dfa38_T274, dfa38_T_empty, dfa38_T_empty, dfa38_T116, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T108, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T2, dfa38_T74, dfa38_T120, dfa38_T270, dfa38_T182, dfa38_T235, 
    dfa38_T234, dfa38_T189, dfa38_T95, dfa38_T217, dfa38_T170, dfa38_T8, 
    dfa38_T203, dfa38_T158, dfa38_T1, dfa38_T15, dfa38_T210, dfa38_T161, 
    dfa38_T10, dfa38_T9, dfa38_T68, dfa38_T143, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T223, dfa38_T209, 
    dfa38_T193, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T260, 
    dfa38_T111, dfa38_T_empty, dfa38_T_empty, dfa38_T319, dfa38_T124, dfa38_T199, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T106, dfa38_T12, dfa38_T322, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T90, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T98, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T176, dfa38_T272, dfa38_T105, dfa38_T289, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T35, dfa38_T145, dfa38_T288, dfa38_T71, dfa38_T271, 
    dfa38_T112, dfa38_T320, dfa38_T0, dfa38_T262, dfa38_T101, dfa38_T96, 
    dfa38_T297, dfa38_T261, dfa38_T323, dfa38_T62, dfa38_T292, dfa38_T299, 
    dfa38_T263, dfa38_T_empty, dfa38_T296, dfa38_T_empty, dfa38_T111, dfa38_T100, 
    dfa38_T139, dfa38_T48, dfa38_T313, dfa38_T273, dfa38_T79, dfa38_T312, 
    dfa38_T281, dfa38_T13, dfa38_T123, dfa38_T201, dfa38_T107, dfa38_T11, 
    dfa38_T321, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T42, dfa38_T87, dfa38_T146, dfa38_T66, dfa38_T104, dfa38_T291, 
    dfa38_T36, dfa38_T144, dfa38_T287, dfa38_T70, dfa38_T0, dfa38_T72, dfa38_T275, 
    dfa38_T58, dfa38_T0, dfa38_T_empty, dfa38_T137, dfa38_T110, dfa38_T102, 
    dfa38_T97, dfa38_T0, dfa38_T93, dfa38_T_empty, dfa38_T328, dfa38_T142, 
    dfa38_T125, dfa38_T293, dfa38_T298, dfa38_T265, dfa38_T_empty, dfa38_T73, 
    dfa38_T163, dfa38_T52, dfa38_T315, dfa38_T89, dfa38_T280, dfa38_T46, 
    dfa38_T129, dfa38_T309, dfa38_T282, dfa38_T4, dfa38_T118, dfa38_T200, 
    dfa38_T0, dfa38_T14, dfa38_T267, dfa38_T0, dfa38_T41, dfa38_T85, dfa38_T147, 
    dfa38_T65, dfa38_T103, dfa38_T290, dfa38_T37, dfa38_T0, dfa38_T0, dfa38_T0, 
    dfa38_T_empty, dfa38_T75, dfa38_T276, dfa38_T60, dfa38_T_empty, dfa38_T138, 
    dfa38_T0, dfa38_T0, dfa38_T94, dfa38_T_empty, dfa38_T91, dfa38_T326, 
    dfa38_T141, dfa38_T126, dfa38_T295, dfa38_T0, dfa38_T264, dfa38_T67, 
    dfa38_T162, dfa38_T49, dfa38_T314, dfa38_T88, dfa38_T279, dfa38_T45, 
    dfa38_T130, dfa38_T308, dfa38_T283, dfa38_T5, dfa38_T0, dfa38_T306, 
    dfa38_T113, dfa38_T_empty, dfa38_T0, dfa38_T266, dfa38_T_empty, dfa38_T40, 
    dfa38_T84, dfa38_T148, dfa38_T69, dfa38_T0, dfa38_T294, dfa38_T38, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T77, dfa38_T277, dfa38_T59, dfa38_T135, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T0, dfa38_T92, dfa38_T325, dfa38_T0, 
    dfa38_T127, dfa38_T0, dfa38_T_empty, dfa38_T0, dfa38_T63, dfa38_T165, 
    dfa38_T57, dfa38_T317, dfa38_T86, dfa38_T278, dfa38_T44, dfa38_T131, 
    dfa38_T311, dfa38_T284, dfa38_T6, dfa38_T_empty, dfa38_T307, dfa38_T0, 
    dfa38_T_empty, dfa38_T269, dfa38_T0, dfa38_T0, dfa38_T0, dfa38_T0, dfa38_T_empty, 
    dfa38_T0, dfa38_T0, dfa38_T78, dfa38_T0, dfa38_T0, dfa38_T136, dfa38_T_empty, 
    dfa38_T0, dfa38_T324, dfa38_T_empty, dfa38_T128, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T61, dfa38_T164, dfa38_T55, dfa38_T316, dfa38_T83, dfa38_T0, dfa38_T53, 
    dfa38_T132, dfa38_T310, dfa38_T285, dfa38_T7, dfa38_T0, dfa38_T_empty, 
    dfa38_T268, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T76, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T140, dfa38_T_empty, dfa38_T0, dfa38_T122, dfa38_T56, dfa38_T167, 
    dfa38_T187, dfa38_T327, dfa38_T82, dfa38_T_empty, dfa38_T54, dfa38_T133, 
    dfa38_T302, dfa38_T286, dfa38_T3, dfa38_T_empty, dfa38_T0, dfa38_T0, 
    dfa38_T0, dfa38_T_empty, dfa38_T0, dfa38_T47, dfa38_T166, dfa38_T149, 
    dfa38_T_empty, dfa38_T64, dfa38_T_empty, dfa38_T81, dfa38_T50, dfa38_T134, 
    dfa38_T303, dfa38_T0, dfa38_T0, dfa38_T_empty, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T_empty, dfa38_T43, dfa38_T169, dfa38_T0, dfa38_T0, dfa38_T80, 
    dfa38_T51, dfa38_T0, dfa38_T304, dfa38_T_empty, dfa38_T_empty, dfa38_T159, 
    dfa38_T39, dfa38_T23, dfa38_T192, dfa38_T224, dfa38_T119, dfa38_T99, 
    dfa38_T168, dfa38_T_empty, dfa38_T_empty, dfa38_T177, dfa38_T0, dfa38_T_empty, 
    dfa38_T305, dfa38_T160, dfa38_T236, dfa38_T21, dfa38_T22, dfa38_T194, 
    dfa38_T226, dfa38_T121, dfa38_T218, dfa38_T230, dfa38_T0, dfa38_T318, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T301, dfa38_T152, dfa38_T239, dfa38_T17, 
    dfa38_T18, dfa38_T197, dfa38_T225, dfa38_T233, dfa38_T245, dfa38_T216, 
    dfa38_T231, dfa38_T_empty, dfa38_T0, dfa38_T0, dfa38_T153, dfa38_T240, 
    dfa38_T181, dfa38_T175, dfa38_T207, dfa38_T114, dfa38_T172, dfa38_T16, 
    dfa38_T198, dfa38_T206, dfa38_T258, dfa38_T244, dfa38_T215, dfa38_T232, 
    dfa38_T_empty, dfa38_T_empty, dfa38_T150, dfa38_T237, dfa38_T180, dfa38_T174, 
    dfa38_T208, dfa38_T115, dfa38_T171, dfa38_T20, dfa38_T195, dfa38_T205, 
    dfa38_T259, dfa38_T247, dfa38_T214, dfa38_T227, dfa38_T151, dfa38_T238, 
    dfa38_T179, dfa38_T173, dfa38_T0, dfa38_T117, dfa38_T0, dfa38_T19, dfa38_T196, 
    dfa38_T204, dfa38_T0, dfa38_T246, dfa38_T213, dfa38_T228, dfa38_T156, 
    dfa38_T242, dfa38_T178, dfa38_T0, dfa38_T_empty, dfa38_T0, dfa38_T_empty, 
    dfa38_T29, dfa38_T185, dfa38_T202, dfa38_T_empty, dfa38_T249, dfa38_T212, 
    dfa38_T229, dfa38_T157, dfa38_T243, dfa38_T0, dfa38_T_empty, dfa38_T_empty, 
    dfa38_T28, dfa38_T186, dfa38_T0, dfa38_T248, dfa38_T211, dfa38_T0, dfa38_T154, 
    dfa38_T241, dfa38_T_empty, dfa38_T31, dfa38_T183, dfa38_T_empty, dfa38_T251, 
    dfa38_T220, dfa38_T_empty, dfa38_T155, dfa38_T0, dfa38_T30, dfa38_T184, 
    dfa38_T250, dfa38_T219, dfa38_T0, dfa38_T_empty, dfa38_T25, dfa38_T190, 
    dfa38_T253, dfa38_T0, dfa38_T_empty, dfa38_T24, dfa38_T191, dfa38_T252, 
    dfa38_T_empty, dfa38_T27, dfa38_T188, dfa38_T255, dfa38_T26, dfa38_T0, 
    dfa38_T254, dfa38_T32, dfa38_T_empty, dfa38_T257, dfa38_T33, dfa38_T256, 
    dfa38_T34, dfa38_T221, dfa38_T0, dfa38_T222, dfa38_T_empty, dfa38_T0, 
    dfa38_T_empty	
};


/* Declare tracking structure for Cyclic DFA 38
 */
static
ANTLR3_CYCLIC_DFA cdfa38
    =	{
	    38,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T25 | T26 | T27 | T28 | T29 | T30 | T31 | T32 | T33 | T34 | T35 | T36 | T37 | T38 | T39 | T40 | T41 | T42 | T43 | T44 | T45 | T46 | T47 | T48 | T49 | T50 | T51 | T52 | T53 | T54 | T55 | T56 | T57 | T58 | T59 | T60 | T61 | T62 | T63 | T64 | T65 | T66 | T67 | T68 | T69 | T70 | T71 | T72 | T73 | T74 | T75 | T76 | T77 | T78 | T79 | T80 | T81 | T82 | T83 | T84 | T85 | T86 | T87 | T88 | T89 | T90 | T91 | T92 | T93 | T94 | T95 | T96 | T97 | T98 | T99 | T100 | T101 | T102 | T103 | T104 | T105 | T106 | T107 | T108 | T109 | T110 | T111 | T112 | T113 | T114 | T115 | T116 | T117 | T118 | T119 | T120 | T121 | T122 | T123 | T124 | T125 | T126 | T127 | T128 | T129 | T130 | T131 | T132 | T133 | IDENTIFIER | CHARACTER_LITERAL | STRING_LITERAL | HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOATING_POINT_LITERAL | WS | COMMENT | LINE_COMMENT | LINE_COMMAND );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa38_eot,	    /* EOT table			    */
	    dfa38_eof,	    /* EOF table			    */
	    dfa38_min,	    /* Minimum tokens for each state    */
	    dfa38_max,	    /* Maximum tokens for each state    */
	    dfa38_accept,	/* Accept table			    */
	    dfa38_special,	/* Special transition states	    */
	    dfa38_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 38
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 12:5: ( '__extension__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T25
 *
 * Looks to match the characters the constitute the token T25
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT25(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T25;
       
    
    // src/C.g:12:5: ( '__extension__' )
    // src/C.g:12:7: '__extension__'
    {
        MATCHS(lit_1); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT25Ex; /* Prevent compiler warnings */
    ruleT25Ex: ;

}
// $ANTLR end T25

//   Comes from: 13:5: ( 'typedef' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T26
 *
 * Looks to match the characters the constitute the token T26
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT26(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T26;
       
    
    // src/C.g:13:5: ( 'typedef' )
    // src/C.g:13:7: 'typedef'
    {
        MATCHS(lit_2); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT26Ex; /* Prevent compiler warnings */
    ruleT26Ex: ;

}
// $ANTLR end T26

//   Comes from: 14:5: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T27
 *
 * Looks to match the characters the constitute the token T27
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT27(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T27;
       
    
    // src/C.g:14:5: ( ';' )
    // src/C.g:14:7: ';'
    {
        MATCHC(';'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT27Ex; /* Prevent compiler warnings */
    ruleT27Ex: ;

}
// $ANTLR end T27

//   Comes from: 15:5: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T28
 *
 * Looks to match the characters the constitute the token T28
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT28(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T28;
       
    
    // src/C.g:15:5: ( ',' )
    // src/C.g:15:7: ','
    {
        MATCHC(','); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT28Ex; /* Prevent compiler warnings */
    ruleT28Ex: ;

}
// $ANTLR end T28

//   Comes from: 16:5: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T29
 *
 * Looks to match the characters the constitute the token T29
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT29(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T29;
       
    
    // src/C.g:16:5: ( '=' )
    // src/C.g:16:7: '='
    {
        MATCHC('='); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT29Ex; /* Prevent compiler warnings */
    ruleT29Ex: ;

}
// $ANTLR end T29

//   Comes from: 17:5: ( '__attribute__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T30
 *
 * Looks to match the characters the constitute the token T30
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT30(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T30;
       
    
    // src/C.g:17:5: ( '__attribute__' )
    // src/C.g:17:7: '__attribute__'
    {
        MATCHS(lit_3); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT30Ex; /* Prevent compiler warnings */
    ruleT30Ex: ;

}
// $ANTLR end T30

//   Comes from: 18:5: ( '__attribute' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T31
 *
 * Looks to match the characters the constitute the token T31
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT31(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T31;
       
    
    // src/C.g:18:5: ( '__attribute' )
    // src/C.g:18:7: '__attribute'
    {
        MATCHS(lit_4); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT31Ex; /* Prevent compiler warnings */
    ruleT31Ex: ;

}
// $ANTLR end T31

//   Comes from: 19:5: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T32
 *
 * Looks to match the characters the constitute the token T32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT32(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T32;
       
    
    // src/C.g:19:5: ( '(' )
    // src/C.g:19:7: '('
    {
        MATCHC('('); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT32Ex; /* Prevent compiler warnings */
    ruleT32Ex: ;

}
// $ANTLR end T32

//   Comes from: 20:5: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T33
 *
 * Looks to match the characters the constitute the token T33
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT33(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T33;
       
    
    // src/C.g:20:5: ( ')' )
    // src/C.g:20:7: ')'
    {
        MATCHC(')'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT33Ex; /* Prevent compiler warnings */
    ruleT33Ex: ;

}
// $ANTLR end T33

//   Comes from: 21:5: ( 'const' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T34
 *
 * Looks to match the characters the constitute the token T34
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT34(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T34;
       
    
    // src/C.g:21:5: ( 'const' )
    // src/C.g:21:7: 'const'
    {
        MATCHS(lit_5); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT34Ex; /* Prevent compiler warnings */
    ruleT34Ex: ;

}
// $ANTLR end T34

//   Comes from: 22:5: ( '__const__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T35
 *
 * Looks to match the characters the constitute the token T35
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT35(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T35;
       
    
    // src/C.g:22:5: ( '__const__' )
    // src/C.g:22:7: '__const__'
    {
        MATCHS(lit_6); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT35Ex; /* Prevent compiler warnings */
    ruleT35Ex: ;

}
// $ANTLR end T35

//   Comes from: 23:5: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T36
 *
 * Looks to match the characters the constitute the token T36
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT36(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T36;
       
    
    // src/C.g:23:5: ( '?' )
    // src/C.g:23:7: '?'
    {
        MATCHC('?'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT36Ex; /* Prevent compiler warnings */
    ruleT36Ex: ;

}
// $ANTLR end T36

//   Comes from: 24:5: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T37
 *
 * Looks to match the characters the constitute the token T37
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT37(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T37;
       
    
    // src/C.g:24:5: ( ':' )
    // src/C.g:24:7: ':'
    {
        MATCHC(':'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT37Ex; /* Prevent compiler warnings */
    ruleT37Ex: ;

}
// $ANTLR end T37

//   Comes from: 25:5: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T38
 *
 * Looks to match the characters the constitute the token T38
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT38(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T38;
       
    
    // src/C.g:25:5: ( '||' )
    // src/C.g:25:7: '||'
    {
        MATCHS(lit_7); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT38Ex; /* Prevent compiler warnings */
    ruleT38Ex: ;

}
// $ANTLR end T38

//   Comes from: 26:5: ( '&&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T39
 *
 * Looks to match the characters the constitute the token T39
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT39(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T39;
       
    
    // src/C.g:26:5: ( '&&' )
    // src/C.g:26:7: '&&'
    {
        MATCHS(lit_8); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT39Ex; /* Prevent compiler warnings */
    ruleT39Ex: ;

}
// $ANTLR end T39

//   Comes from: 27:5: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T40
 *
 * Looks to match the characters the constitute the token T40
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT40(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T40;
       
    
    // src/C.g:27:5: ( '|' )
    // src/C.g:27:7: '|'
    {
        MATCHC('|'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT40Ex; /* Prevent compiler warnings */
    ruleT40Ex: ;

}
// $ANTLR end T40

//   Comes from: 28:5: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T41
 *
 * Looks to match the characters the constitute the token T41
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT41(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T41;
       
    
    // src/C.g:28:5: ( '^' )
    // src/C.g:28:7: '^'
    {
        MATCHC('^'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT41Ex; /* Prevent compiler warnings */
    ruleT41Ex: ;

}
// $ANTLR end T41

//   Comes from: 29:5: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T42
 *
 * Looks to match the characters the constitute the token T42
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT42(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T42;
       
    
    // src/C.g:29:5: ( '&' )
    // src/C.g:29:7: '&'
    {
        MATCHC('&'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT42Ex; /* Prevent compiler warnings */
    ruleT42Ex: ;

}
// $ANTLR end T42

//   Comes from: 30:5: ( '==' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T43
 *
 * Looks to match the characters the constitute the token T43
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT43(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T43;
       
    
    // src/C.g:30:5: ( '==' )
    // src/C.g:30:7: '=='
    {
        MATCHS(lit_9); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT43Ex; /* Prevent compiler warnings */
    ruleT43Ex: ;

}
// $ANTLR end T43

//   Comes from: 31:5: ( '!=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T44
 *
 * Looks to match the characters the constitute the token T44
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT44(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T44;
       
    
    // src/C.g:31:5: ( '!=' )
    // src/C.g:31:7: '!='
    {
        MATCHS(lit_10); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT44Ex; /* Prevent compiler warnings */
    ruleT44Ex: ;

}
// $ANTLR end T44

//   Comes from: 32:5: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T45
 *
 * Looks to match the characters the constitute the token T45
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT45(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T45;
       
    
    // src/C.g:32:5: ( '<' )
    // src/C.g:32:7: '<'
    {
        MATCHC('<'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT45Ex; /* Prevent compiler warnings */
    ruleT45Ex: ;

}
// $ANTLR end T45

//   Comes from: 33:5: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T46
 *
 * Looks to match the characters the constitute the token T46
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT46(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T46;
       
    
    // src/C.g:33:5: ( '>' )
    // src/C.g:33:7: '>'
    {
        MATCHC('>'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT46Ex; /* Prevent compiler warnings */
    ruleT46Ex: ;

}
// $ANTLR end T46

//   Comes from: 34:5: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T47
 *
 * Looks to match the characters the constitute the token T47
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT47(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T47;
       
    
    // src/C.g:34:5: ( '<=' )
    // src/C.g:34:7: '<='
    {
        MATCHS(lit_11); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT47Ex; /* Prevent compiler warnings */
    ruleT47Ex: ;

}
// $ANTLR end T47

//   Comes from: 35:5: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T48
 *
 * Looks to match the characters the constitute the token T48
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT48(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T48;
       
    
    // src/C.g:35:5: ( '>=' )
    // src/C.g:35:7: '>='
    {
        MATCHS(lit_12); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT48Ex; /* Prevent compiler warnings */
    ruleT48Ex: ;

}
// $ANTLR end T48

//   Comes from: 36:5: ( '<<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T49
 *
 * Looks to match the characters the constitute the token T49
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT49(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T49;
       
    
    // src/C.g:36:5: ( '<<' )
    // src/C.g:36:7: '<<'
    {
        MATCHS(lit_13); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT49Ex; /* Prevent compiler warnings */
    ruleT49Ex: ;

}
// $ANTLR end T49

//   Comes from: 37:5: ( '>>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T50
 *
 * Looks to match the characters the constitute the token T50
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT50(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T50;
       
    
    // src/C.g:37:5: ( '>>' )
    // src/C.g:37:7: '>>'
    {
        MATCHS(lit_14); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT50Ex; /* Prevent compiler warnings */
    ruleT50Ex: ;

}
// $ANTLR end T50

//   Comes from: 38:5: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T51
 *
 * Looks to match the characters the constitute the token T51
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT51(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T51;
       
    
    // src/C.g:38:5: ( '+' )
    // src/C.g:38:7: '+'
    {
        MATCHC('+'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT51Ex; /* Prevent compiler warnings */
    ruleT51Ex: ;

}
// $ANTLR end T51

//   Comes from: 39:5: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T52
 *
 * Looks to match the characters the constitute the token T52
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT52(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T52;
       
    
    // src/C.g:39:5: ( '-' )
    // src/C.g:39:7: '-'
    {
        MATCHC('-'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT52Ex; /* Prevent compiler warnings */
    ruleT52Ex: ;

}
// $ANTLR end T52

//   Comes from: 40:5: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T53
 *
 * Looks to match the characters the constitute the token T53
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT53(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T53;
       
    
    // src/C.g:40:5: ( '*' )
    // src/C.g:40:7: '*'
    {
        MATCHC('*'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT53Ex; /* Prevent compiler warnings */
    ruleT53Ex: ;

}
// $ANTLR end T53

//   Comes from: 41:5: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T54
 *
 * Looks to match the characters the constitute the token T54
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT54(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T54;
       
    
    // src/C.g:41:5: ( '/' )
    // src/C.g:41:7: '/'
    {
        MATCHC('/'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT54Ex; /* Prevent compiler warnings */
    ruleT54Ex: ;

}
// $ANTLR end T54

//   Comes from: 42:5: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T55
 *
 * Looks to match the characters the constitute the token T55
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT55(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T55;
       
    
    // src/C.g:42:5: ( '%' )
    // src/C.g:42:7: '%'
    {
        MATCHC('%'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT55Ex; /* Prevent compiler warnings */
    ruleT55Ex: ;

}
// $ANTLR end T55

//   Comes from: 43:5: ( 'sizeof' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T56
 *
 * Looks to match the characters the constitute the token T56
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT56(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T56;
       
    
    // src/C.g:43:5: ( 'sizeof' )
    // src/C.g:43:7: 'sizeof'
    {
        MATCHS(lit_15); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT56Ex; /* Prevent compiler warnings */
    ruleT56Ex: ;

}
// $ANTLR end T56

//   Comes from: 44:5: ( '__alignof__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T57
 *
 * Looks to match the characters the constitute the token T57
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT57(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T57;
       
    
    // src/C.g:44:5: ( '__alignof__' )
    // src/C.g:44:7: '__alignof__'
    {
        MATCHS(lit_16); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT57Ex; /* Prevent compiler warnings */
    ruleT57Ex: ;

}
// $ANTLR end T57

//   Comes from: 45:5: ( '__builtin_types_compatible_p' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T58
 *
 * Looks to match the characters the constitute the token T58
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT58(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T58;
       
    
    // src/C.g:45:5: ( '__builtin_types_compatible_p' )
    // src/C.g:45:7: '__builtin_types_compatible_p'
    {
        MATCHS(lit_17); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT58Ex; /* Prevent compiler warnings */
    ruleT58Ex: ;

}
// $ANTLR end T58

//   Comes from: 46:5: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T59
 *
 * Looks to match the characters the constitute the token T59
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT59(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T59;
       
    
    // src/C.g:46:5: ( '.' )
    // src/C.g:46:7: '.'
    {
        MATCHC('.'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT59Ex; /* Prevent compiler warnings */
    ruleT59Ex: ;

}
// $ANTLR end T59

//   Comes from: 47:5: ( 'extern' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T60
 *
 * Looks to match the characters the constitute the token T60
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT60(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T60;
       
    
    // src/C.g:47:5: ( 'extern' )
    // src/C.g:47:7: 'extern'
    {
        MATCHS(lit_18); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT60Ex; /* Prevent compiler warnings */
    ruleT60Ex: ;

}
// $ANTLR end T60

//   Comes from: 48:5: ( 'static' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T61
 *
 * Looks to match the characters the constitute the token T61
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT61(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T61;
       
    
    // src/C.g:48:5: ( 'static' )
    // src/C.g:48:7: 'static'
    {
        MATCHS(lit_19); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT61Ex; /* Prevent compiler warnings */
    ruleT61Ex: ;

}
// $ANTLR end T61

//   Comes from: 49:5: ( 'auto' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T62
 *
 * Looks to match the characters the constitute the token T62
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT62(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T62;
       
    
    // src/C.g:49:5: ( 'auto' )
    // src/C.g:49:7: 'auto'
    {
        MATCHS(lit_20); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT62Ex; /* Prevent compiler warnings */
    ruleT62Ex: ;

}
// $ANTLR end T62

//   Comes from: 50:5: ( 'register' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T63
 *
 * Looks to match the characters the constitute the token T63
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT63(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T63;
       
    
    // src/C.g:50:5: ( 'register' )
    // src/C.g:50:7: 'register'
    {
        MATCHS(lit_21); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT63Ex; /* Prevent compiler warnings */
    ruleT63Ex: ;

}
// $ANTLR end T63

//   Comes from: 51:5: ( 'inline' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T64
 *
 * Looks to match the characters the constitute the token T64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT64(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T64;
       
    
    // src/C.g:51:5: ( 'inline' )
    // src/C.g:51:7: 'inline'
    {
        MATCHS(lit_22); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT64Ex; /* Prevent compiler warnings */
    ruleT64Ex: ;

}
// $ANTLR end T64

//   Comes from: 52:5: ( '__inline' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T65
 *
 * Looks to match the characters the constitute the token T65
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT65(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T65;
       
    
    // src/C.g:52:5: ( '__inline' )
    // src/C.g:52:7: '__inline'
    {
        MATCHS(lit_23); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT65Ex; /* Prevent compiler warnings */
    ruleT65Ex: ;

}
// $ANTLR end T65

//   Comes from: 53:5: ( '__inline__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T66
 *
 * Looks to match the characters the constitute the token T66
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT66(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T66;
       
    
    // src/C.g:53:5: ( '__inline__' )
    // src/C.g:53:7: '__inline__'
    {
        MATCHS(lit_24); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT66Ex; /* Prevent compiler warnings */
    ruleT66Ex: ;

}
// $ANTLR end T66

//   Comes from: 54:5: ( 'void' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T67
 *
 * Looks to match the characters the constitute the token T67
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT67(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T67;
       
    
    // src/C.g:54:5: ( 'void' )
    // src/C.g:54:7: 'void'
    {
        MATCHS(lit_25); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT67Ex; /* Prevent compiler warnings */
    ruleT67Ex: ;

}
// $ANTLR end T67

//   Comes from: 55:5: ( 'char' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T68
 *
 * Looks to match the characters the constitute the token T68
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT68(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T68;
       
    
    // src/C.g:55:5: ( 'char' )
    // src/C.g:55:7: 'char'
    {
        MATCHS(lit_26); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT68Ex; /* Prevent compiler warnings */
    ruleT68Ex: ;

}
// $ANTLR end T68

//   Comes from: 56:5: ( 'short' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T69
 *
 * Looks to match the characters the constitute the token T69
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT69(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T69;
       
    
    // src/C.g:56:5: ( 'short' )
    // src/C.g:56:7: 'short'
    {
        MATCHS(lit_27); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT69Ex; /* Prevent compiler warnings */
    ruleT69Ex: ;

}
// $ANTLR end T69

//   Comes from: 57:5: ( 'int' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T70
 *
 * Looks to match the characters the constitute the token T70
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT70(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T70;
       
    
    // src/C.g:57:5: ( 'int' )
    // src/C.g:57:7: 'int'
    {
        MATCHS(lit_28); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT70Ex; /* Prevent compiler warnings */
    ruleT70Ex: ;

}
// $ANTLR end T70

//   Comes from: 58:5: ( 'long' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T71
 *
 * Looks to match the characters the constitute the token T71
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT71(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T71;
       
    
    // src/C.g:58:5: ( 'long' )
    // src/C.g:58:7: 'long'
    {
        MATCHS(lit_29); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT71Ex; /* Prevent compiler warnings */
    ruleT71Ex: ;

}
// $ANTLR end T71

//   Comes from: 59:5: ( 'float' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T72
 *
 * Looks to match the characters the constitute the token T72
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT72(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T72;
       
    
    // src/C.g:59:5: ( 'float' )
    // src/C.g:59:7: 'float'
    {
        MATCHS(lit_30); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT72Ex; /* Prevent compiler warnings */
    ruleT72Ex: ;

}
// $ANTLR end T72

//   Comes from: 60:5: ( 'double' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T73
 *
 * Looks to match the characters the constitute the token T73
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT73(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T73;
       
    
    // src/C.g:60:5: ( 'double' )
    // src/C.g:60:7: 'double'
    {
        MATCHS(lit_31); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT73Ex; /* Prevent compiler warnings */
    ruleT73Ex: ;

}
// $ANTLR end T73

//   Comes from: 61:5: ( 'signed' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T74
 *
 * Looks to match the characters the constitute the token T74
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT74(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T74;
       
    
    // src/C.g:61:5: ( 'signed' )
    // src/C.g:61:7: 'signed'
    {
        MATCHS(lit_32); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT74Ex; /* Prevent compiler warnings */
    ruleT74Ex: ;

}
// $ANTLR end T74

//   Comes from: 62:5: ( '__signed__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T75
 *
 * Looks to match the characters the constitute the token T75
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT75(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T75;
       
    
    // src/C.g:62:5: ( '__signed__' )
    // src/C.g:62:7: '__signed__'
    {
        MATCHS(lit_33); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT75Ex; /* Prevent compiler warnings */
    ruleT75Ex: ;

}
// $ANTLR end T75

//   Comes from: 63:5: ( 'unsigned' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T76
 *
 * Looks to match the characters the constitute the token T76
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT76(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T76;
       
    
    // src/C.g:63:5: ( 'unsigned' )
    // src/C.g:63:7: 'unsigned'
    {
        MATCHS(lit_34); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT76Ex; /* Prevent compiler warnings */
    ruleT76Ex: ;

}
// $ANTLR end T76

//   Comes from: 64:5: ( '_Bool' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T77
 *
 * Looks to match the characters the constitute the token T77
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT77(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T77;
       
    
    // src/C.g:64:5: ( '_Bool' )
    // src/C.g:64:7: '_Bool'
    {
        MATCHS(lit_35); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT77Ex; /* Prevent compiler warnings */
    ruleT77Ex: ;

}
// $ANTLR end T77

//   Comes from: 65:5: ( '__builtin_va_list' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T78
 *
 * Looks to match the characters the constitute the token T78
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT78(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T78;
       
    
    // src/C.g:65:5: ( '__builtin_va_list' )
    // src/C.g:65:7: '__builtin_va_list'
    {
        MATCHS(lit_36); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT78Ex; /* Prevent compiler warnings */
    ruleT78Ex: ;

}
// $ANTLR end T78

//   Comes from: 66:5: ( 'typeof' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T79
 *
 * Looks to match the characters the constitute the token T79
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT79(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T79;
       
    
    // src/C.g:66:5: ( 'typeof' )
    // src/C.g:66:7: 'typeof'
    {
        MATCHS(lit_37); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT79Ex; /* Prevent compiler warnings */
    ruleT79Ex: ;

}
// $ANTLR end T79

//   Comes from: 67:5: ( '__typeof' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T80
 *
 * Looks to match the characters the constitute the token T80
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT80(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T80;
       
    
    // src/C.g:67:5: ( '__typeof' )
    // src/C.g:67:7: '__typeof'
    {
        MATCHS(lit_38); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT80Ex; /* Prevent compiler warnings */
    ruleT80Ex: ;

}
// $ANTLR end T80

//   Comes from: 68:5: ( '__typeof__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T81
 *
 * Looks to match the characters the constitute the token T81
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT81(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T81;
       
    
    // src/C.g:68:5: ( '__typeof__' )
    // src/C.g:68:7: '__typeof__'
    {
        MATCHS(lit_39); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT81Ex; /* Prevent compiler warnings */
    ruleT81Ex: ;

}
// $ANTLR end T81

//   Comes from: 69:5: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T82
 *
 * Looks to match the characters the constitute the token T82
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT82(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T82;
       
    
    // src/C.g:69:5: ( '{' )
    // src/C.g:69:7: '{'
    {
        MATCHC('{'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT82Ex; /* Prevent compiler warnings */
    ruleT82Ex: ;

}
// $ANTLR end T82

//   Comes from: 70:5: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T83
 *
 * Looks to match the characters the constitute the token T83
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT83(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T83;
       
    
    // src/C.g:70:5: ( '}' )
    // src/C.g:70:7: '}'
    {
        MATCHC('}'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT83Ex; /* Prevent compiler warnings */
    ruleT83Ex: ;

}
// $ANTLR end T83

//   Comes from: 71:5: ( 'struct' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T84
 *
 * Looks to match the characters the constitute the token T84
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT84(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T84;
       
    
    // src/C.g:71:5: ( 'struct' )
    // src/C.g:71:7: 'struct'
    {
        MATCHS(lit_40); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT84Ex; /* Prevent compiler warnings */
    ruleT84Ex: ;

}
// $ANTLR end T84

//   Comes from: 72:5: ( 'union' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T85
 *
 * Looks to match the characters the constitute the token T85
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT85(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T85;
       
    
    // src/C.g:72:5: ( 'union' )
    // src/C.g:72:7: 'union'
    {
        MATCHS(lit_41); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT85Ex; /* Prevent compiler warnings */
    ruleT85Ex: ;

}
// $ANTLR end T85

//   Comes from: 73:5: ( 'enum' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T86
 *
 * Looks to match the characters the constitute the token T86
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT86(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T86;
       
    
    // src/C.g:73:5: ( 'enum' )
    // src/C.g:73:7: 'enum'
    {
        MATCHS(lit_42); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT86Ex; /* Prevent compiler warnings */
    ruleT86Ex: ;

}
// $ANTLR end T86

//   Comes from: 74:5: ( 'volatile' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T87
 *
 * Looks to match the characters the constitute the token T87
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT87(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T87;
       
    
    // src/C.g:74:5: ( 'volatile' )
    // src/C.g:74:7: 'volatile'
    {
        MATCHS(lit_43); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT87Ex; /* Prevent compiler warnings */
    ruleT87Ex: ;

}
// $ANTLR end T87

//   Comes from: 75:5: ( '__volatile__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T88
 *
 * Looks to match the characters the constitute the token T88
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT88(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T88;
       
    
    // src/C.g:75:5: ( '__volatile__' )
    // src/C.g:75:7: '__volatile__'
    {
        MATCHS(lit_44); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT88Ex; /* Prevent compiler warnings */
    ruleT88Ex: ;

}
// $ANTLR end T88

//   Comes from: 76:5: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T89
 *
 * Looks to match the characters the constitute the token T89
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT89(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T89;
       
    
    // src/C.g:76:5: ( '[' )
    // src/C.g:76:7: '['
    {
        MATCHC('['); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT89Ex; /* Prevent compiler warnings */
    ruleT89Ex: ;

}
// $ANTLR end T89

//   Comes from: 77:5: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T90
 *
 * Looks to match the characters the constitute the token T90
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT90(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T90;
       
    
    // src/C.g:77:5: ( ']' )
    // src/C.g:77:7: ']'
    {
        MATCHC(']'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT90Ex; /* Prevent compiler warnings */
    ruleT90Ex: ;

}
// $ANTLR end T90

//   Comes from: 78:5: ( '...' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T91
 *
 * Looks to match the characters the constitute the token T91
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT91(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T91;
       
    
    // src/C.g:78:5: ( '...' )
    // src/C.g:78:7: '...'
    {
        MATCHS(lit_45); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT91Ex; /* Prevent compiler warnings */
    ruleT91Ex: ;

}
// $ANTLR end T91

//   Comes from: 79:5: ( '++' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T92
 *
 * Looks to match the characters the constitute the token T92
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT92(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T92;
       
    
    // src/C.g:79:5: ( '++' )
    // src/C.g:79:7: '++'
    {
        MATCHS(lit_46); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT92Ex; /* Prevent compiler warnings */
    ruleT92Ex: ;

}
// $ANTLR end T92

//   Comes from: 80:5: ( '--' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T93
 *
 * Looks to match the characters the constitute the token T93
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT93(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T93;
       
    
    // src/C.g:80:5: ( '--' )
    // src/C.g:80:7: '--'
    {
        MATCHS(lit_47); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT93Ex; /* Prevent compiler warnings */
    ruleT93Ex: ;

}
// $ANTLR end T93

//   Comes from: 81:5: ( '__builtin_choose_expr' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T94
 *
 * Looks to match the characters the constitute the token T94
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT94(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T94;
       
    
    // src/C.g:81:5: ( '__builtin_choose_expr' )
    // src/C.g:81:7: '__builtin_choose_expr'
    {
        MATCHS(lit_48); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT94Ex; /* Prevent compiler warnings */
    ruleT94Ex: ;

}
// $ANTLR end T94

//   Comes from: 82:5: ( '__builtin_constant_p' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T95
 *
 * Looks to match the characters the constitute the token T95
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT95(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T95;
       
    
    // src/C.g:82:5: ( '__builtin_constant_p' )
    // src/C.g:82:7: '__builtin_constant_p'
    {
        MATCHS(lit_49); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT95Ex; /* Prevent compiler warnings */
    ruleT95Ex: ;

}
// $ANTLR end T95

//   Comes from: 83:5: ( '__builtin_expect' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T96
 *
 * Looks to match the characters the constitute the token T96
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT96(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T96;
       
    
    // src/C.g:83:5: ( '__builtin_expect' )
    // src/C.g:83:7: '__builtin_expect'
    {
        MATCHS(lit_50); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT96Ex; /* Prevent compiler warnings */
    ruleT96Ex: ;

}
// $ANTLR end T96

//   Comes from: 84:5: ( '__builtin_extract_return_addr' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T97
 *
 * Looks to match the characters the constitute the token T97
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT97(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T97;
       
    
    // src/C.g:84:5: ( '__builtin_extract_return_addr' )
    // src/C.g:84:7: '__builtin_extract_return_addr'
    {
        MATCHS(lit_51); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT97Ex; /* Prevent compiler warnings */
    ruleT97Ex: ;

}
// $ANTLR end T97

//   Comes from: 85:5: ( '__builtin_object_size' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T98
 *
 * Looks to match the characters the constitute the token T98
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT98(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T98;
       
    
    // src/C.g:85:5: ( '__builtin_object_size' )
    // src/C.g:85:7: '__builtin_object_size'
    {
        MATCHS(lit_52); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT98Ex; /* Prevent compiler warnings */
    ruleT98Ex: ;

}
// $ANTLR end T98

//   Comes from: 86:5: ( '__builtin_offsetof' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T99
 *
 * Looks to match the characters the constitute the token T99
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT99(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T99;
       
    
    // src/C.g:86:5: ( '__builtin_offsetof' )
    // src/C.g:86:7: '__builtin_offsetof'
    {
        MATCHS(lit_53); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT99Ex; /* Prevent compiler warnings */
    ruleT99Ex: ;

}
// $ANTLR end T99

//   Comes from: 87:6: ( '__builtin_prefetch' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T100
 *
 * Looks to match the characters the constitute the token T100
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT100(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T100;
       
    
    // src/C.g:87:6: ( '__builtin_prefetch' )
    // src/C.g:87:8: '__builtin_prefetch'
    {
        MATCHS(lit_54); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT100Ex; /* Prevent compiler warnings */
    ruleT100Ex: ;

}
// $ANTLR end T100

//   Comes from: 88:6: ( '__builtin_return_address' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T101
 *
 * Looks to match the characters the constitute the token T101
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT101(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T101;
       
    
    // src/C.g:88:6: ( '__builtin_return_address' )
    // src/C.g:88:8: '__builtin_return_address'
    {
        MATCHS(lit_55); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT101Ex; /* Prevent compiler warnings */
    ruleT101Ex: ;

}
// $ANTLR end T101

//   Comes from: 89:6: ( '__builtin_va_arg' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T102
 *
 * Looks to match the characters the constitute the token T102
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT102(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T102;
       
    
    // src/C.g:89:6: ( '__builtin_va_arg' )
    // src/C.g:89:8: '__builtin_va_arg'
    {
        MATCHS(lit_56); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT102Ex; /* Prevent compiler warnings */
    ruleT102Ex: ;

}
// $ANTLR end T102

//   Comes from: 90:6: ( '__builtin_va_copy' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T103
 *
 * Looks to match the characters the constitute the token T103
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT103(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T103;
       
    
    // src/C.g:90:6: ( '__builtin_va_copy' )
    // src/C.g:90:8: '__builtin_va_copy'
    {
        MATCHS(lit_57); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT103Ex; /* Prevent compiler warnings */
    ruleT103Ex: ;

}
// $ANTLR end T103

//   Comes from: 91:6: ( '__builtin_va_end' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T104
 *
 * Looks to match the characters the constitute the token T104
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT104(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T104;
       
    
    // src/C.g:91:6: ( '__builtin_va_end' )
    // src/C.g:91:8: '__builtin_va_end'
    {
        MATCHS(lit_58); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT104Ex; /* Prevent compiler warnings */
    ruleT104Ex: ;

}
// $ANTLR end T104

//   Comes from: 92:6: ( '__builtin_va_start' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T105
 *
 * Looks to match the characters the constitute the token T105
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT105(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T105;
       
    
    // src/C.g:92:6: ( '__builtin_va_start' )
    // src/C.g:92:8: '__builtin_va_start'
    {
        MATCHS(lit_59); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT105Ex; /* Prevent compiler warnings */
    ruleT105Ex: ;

}
// $ANTLR end T105

//   Comes from: 93:6: ( '->' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T106
 *
 * Looks to match the characters the constitute the token T106
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT106(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T106;
       
    
    // src/C.g:93:6: ( '->' )
    // src/C.g:93:8: '->'
    {
        MATCHS(lit_60); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT106Ex; /* Prevent compiler warnings */
    ruleT106Ex: ;

}
// $ANTLR end T106

//   Comes from: 94:6: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T107
 *
 * Looks to match the characters the constitute the token T107
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT107(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T107;
       
    
    // src/C.g:94:6: ( '~' )
    // src/C.g:94:8: '~'
    {
        MATCHC('~'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT107Ex; /* Prevent compiler warnings */
    ruleT107Ex: ;

}
// $ANTLR end T107

//   Comes from: 95:6: ( '!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T108
 *
 * Looks to match the characters the constitute the token T108
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT108(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T108;
       
    
    // src/C.g:95:6: ( '!' )
    // src/C.g:95:8: '!'
    {
        MATCHC('!'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT108Ex; /* Prevent compiler warnings */
    ruleT108Ex: ;

}
// $ANTLR end T108

//   Comes from: 96:6: ( '*=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T109
 *
 * Looks to match the characters the constitute the token T109
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT109(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T109;
       
    
    // src/C.g:96:6: ( '*=' )
    // src/C.g:96:8: '*='
    {
        MATCHS(lit_61); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT109Ex; /* Prevent compiler warnings */
    ruleT109Ex: ;

}
// $ANTLR end T109

//   Comes from: 97:6: ( '/=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T110
 *
 * Looks to match the characters the constitute the token T110
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT110(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T110;
       
    
    // src/C.g:97:6: ( '/=' )
    // src/C.g:97:8: '/='
    {
        MATCHS(lit_62); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT110Ex; /* Prevent compiler warnings */
    ruleT110Ex: ;

}
// $ANTLR end T110

//   Comes from: 98:6: ( '%=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T111
 *
 * Looks to match the characters the constitute the token T111
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT111(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T111;
       
    
    // src/C.g:98:6: ( '%=' )
    // src/C.g:98:8: '%='
    {
        MATCHS(lit_63); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT111Ex; /* Prevent compiler warnings */
    ruleT111Ex: ;

}
// $ANTLR end T111

//   Comes from: 99:6: ( '+=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T112
 *
 * Looks to match the characters the constitute the token T112
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT112(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T112;
       
    
    // src/C.g:99:6: ( '+=' )
    // src/C.g:99:8: '+='
    {
        MATCHS(lit_64); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT112Ex; /* Prevent compiler warnings */
    ruleT112Ex: ;

}
// $ANTLR end T112

//   Comes from: 100:6: ( '-=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T113
 *
 * Looks to match the characters the constitute the token T113
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT113(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T113;
       
    
    // src/C.g:100:6: ( '-=' )
    // src/C.g:100:8: '-='
    {
        MATCHS(lit_65); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT113Ex; /* Prevent compiler warnings */
    ruleT113Ex: ;

}
// $ANTLR end T113

//   Comes from: 101:6: ( '<<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T114
 *
 * Looks to match the characters the constitute the token T114
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT114(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T114;
       
    
    // src/C.g:101:6: ( '<<=' )
    // src/C.g:101:8: '<<='
    {
        MATCHS(lit_66); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT114Ex; /* Prevent compiler warnings */
    ruleT114Ex: ;

}
// $ANTLR end T114

//   Comes from: 102:6: ( '>>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T115
 *
 * Looks to match the characters the constitute the token T115
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT115(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T115;
       
    
    // src/C.g:102:6: ( '>>=' )
    // src/C.g:102:8: '>>='
    {
        MATCHS(lit_67); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT115Ex; /* Prevent compiler warnings */
    ruleT115Ex: ;

}
// $ANTLR end T115

//   Comes from: 103:6: ( '&=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T116
 *
 * Looks to match the characters the constitute the token T116
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT116(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T116;
       
    
    // src/C.g:103:6: ( '&=' )
    // src/C.g:103:8: '&='
    {
        MATCHS(lit_68); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT116Ex; /* Prevent compiler warnings */
    ruleT116Ex: ;

}
// $ANTLR end T116

//   Comes from: 104:6: ( '^=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T117
 *
 * Looks to match the characters the constitute the token T117
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT117(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T117;
       
    
    // src/C.g:104:6: ( '^=' )
    // src/C.g:104:8: '^='
    {
        MATCHS(lit_69); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT117Ex; /* Prevent compiler warnings */
    ruleT117Ex: ;

}
// $ANTLR end T117

//   Comes from: 105:6: ( '|=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T118
 *
 * Looks to match the characters the constitute the token T118
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT118(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T118;
       
    
    // src/C.g:105:6: ( '|=' )
    // src/C.g:105:8: '|='
    {
        MATCHS(lit_70); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT118Ex; /* Prevent compiler warnings */
    ruleT118Ex: ;

}
// $ANTLR end T118

//   Comes from: 106:6: ( 'case' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T119
 *
 * Looks to match the characters the constitute the token T119
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT119(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T119;
       
    
    // src/C.g:106:6: ( 'case' )
    // src/C.g:106:8: 'case'
    {
        MATCHS(lit_71); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT119Ex; /* Prevent compiler warnings */
    ruleT119Ex: ;

}
// $ANTLR end T119

//   Comes from: 107:6: ( 'default' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T120
 *
 * Looks to match the characters the constitute the token T120
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT120(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T120;
       
    
    // src/C.g:107:6: ( 'default' )
    // src/C.g:107:8: 'default'
    {
        MATCHS(lit_72); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT120Ex; /* Prevent compiler warnings */
    ruleT120Ex: ;

}
// $ANTLR end T120

//   Comes from: 108:6: ( '__label__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T121
 *
 * Looks to match the characters the constitute the token T121
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT121(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T121;
       
    
    // src/C.g:108:6: ( '__label__' )
    // src/C.g:108:8: '__label__'
    {
        MATCHS(lit_73); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT121Ex; /* Prevent compiler warnings */
    ruleT121Ex: ;

}
// $ANTLR end T121

//   Comes from: 109:6: ( 'if' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T122
 *
 * Looks to match the characters the constitute the token T122
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT122(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T122;
       
    
    // src/C.g:109:6: ( 'if' )
    // src/C.g:109:8: 'if'
    {
        MATCHS(lit_74); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT122Ex; /* Prevent compiler warnings */
    ruleT122Ex: ;

}
// $ANTLR end T122

//   Comes from: 110:6: ( 'else' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T123
 *
 * Looks to match the characters the constitute the token T123
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT123(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T123;
       
    
    // src/C.g:110:6: ( 'else' )
    // src/C.g:110:8: 'else'
    {
        MATCHS(lit_75); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT123Ex; /* Prevent compiler warnings */
    ruleT123Ex: ;

}
// $ANTLR end T123

//   Comes from: 111:6: ( 'switch' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T124
 *
 * Looks to match the characters the constitute the token T124
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT124(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T124;
       
    
    // src/C.g:111:6: ( 'switch' )
    // src/C.g:111:8: 'switch'
    {
        MATCHS(lit_76); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT124Ex; /* Prevent compiler warnings */
    ruleT124Ex: ;

}
// $ANTLR end T124

//   Comes from: 112:6: ( 'while' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T125
 *
 * Looks to match the characters the constitute the token T125
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT125(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T125;
       
    
    // src/C.g:112:6: ( 'while' )
    // src/C.g:112:8: 'while'
    {
        MATCHS(lit_77); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT125Ex; /* Prevent compiler warnings */
    ruleT125Ex: ;

}
// $ANTLR end T125

//   Comes from: 113:6: ( 'do' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T126
 *
 * Looks to match the characters the constitute the token T126
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT126(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T126;
       
    
    // src/C.g:113:6: ( 'do' )
    // src/C.g:113:8: 'do'
    {
        MATCHS(lit_78); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT126Ex; /* Prevent compiler warnings */
    ruleT126Ex: ;

}
// $ANTLR end T126

//   Comes from: 114:6: ( 'for' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T127
 *
 * Looks to match the characters the constitute the token T127
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT127(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T127;
       
    
    // src/C.g:114:6: ( 'for' )
    // src/C.g:114:8: 'for'
    {
        MATCHS(lit_79); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT127Ex; /* Prevent compiler warnings */
    ruleT127Ex: ;

}
// $ANTLR end T127

//   Comes from: 115:6: ( 'goto' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T128
 *
 * Looks to match the characters the constitute the token T128
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT128(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T128;
       
    
    // src/C.g:115:6: ( 'goto' )
    // src/C.g:115:8: 'goto'
    {
        MATCHS(lit_80); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT128Ex; /* Prevent compiler warnings */
    ruleT128Ex: ;

}
// $ANTLR end T128

//   Comes from: 116:6: ( 'continue' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T129
 *
 * Looks to match the characters the constitute the token T129
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT129(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T129;
       
    
    // src/C.g:116:6: ( 'continue' )
    // src/C.g:116:8: 'continue'
    {
        MATCHS(lit_81); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT129Ex; /* Prevent compiler warnings */
    ruleT129Ex: ;

}
// $ANTLR end T129

//   Comes from: 117:6: ( 'break' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T130
 *
 * Looks to match the characters the constitute the token T130
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT130(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T130;
       
    
    // src/C.g:117:6: ( 'break' )
    // src/C.g:117:8: 'break'
    {
        MATCHS(lit_82); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT130Ex; /* Prevent compiler warnings */
    ruleT130Ex: ;

}
// $ANTLR end T130

//   Comes from: 118:6: ( 'return' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T131
 *
 * Looks to match the characters the constitute the token T131
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT131(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T131;
       
    
    // src/C.g:118:6: ( 'return' )
    // src/C.g:118:8: 'return'
    {
        MATCHS(lit_83); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT131Ex; /* Prevent compiler warnings */
    ruleT131Ex: ;

}
// $ANTLR end T131

//   Comes from: 119:6: ( 'asm' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T132
 *
 * Looks to match the characters the constitute the token T132
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT132(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T132;
       
    
    // src/C.g:119:6: ( 'asm' )
    // src/C.g:119:8: 'asm'
    {
        MATCHS(lit_84); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT132Ex; /* Prevent compiler warnings */
    ruleT132Ex: ;

}
// $ANTLR end T132

//   Comes from: 120:6: ( '__asm__' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T133
 *
 * Looks to match the characters the constitute the token T133
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT133(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = T133;
       
    
    // src/C.g:120:6: ( '__asm__' )
    // src/C.g:120:8: '__asm__'
    {
        MATCHS(lit_85); 



    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT133Ex; /* Prevent compiler warnings */
    ruleT133Ex: ;

}
// $ANTLR end T133

//   Comes from: 2423:5: ( LETTER ( LETTER | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IDENTIFIER
 *
 * Looks to match the characters the constitute the token IDENTIFIER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIDENTIFIER(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = IDENTIFIER;
       
    
    // src/C.g:2423:5: ( LETTER ( LETTER | '0' .. '9' )* )
    // src/C.g:2423:9: LETTER ( LETTER | '0' .. '9' )*
    {
        /* 2423:9: LETTER ( LETTER | '0' .. '9' )* */
        mLETTER(ctx ); 


        // src/C.g:2423:16: ( LETTER | '0' .. '9' )*

        for (;;)
        {
            int alt1=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = LA(1);
                if ( (LA1_0 == '$' || ((LA1_0 >= '0') && (LA1_0 <= '9')) || ((LA1_0 >= 'A') && (LA1_0 <= 'Z')) || LA1_0 == '_' || ((LA1_0 >= 'a') && (LA1_0 <= 'z'))) ) 
                {
                    alt1=1;
                }

            }
            switch (alt1) 
            {
        	case 1:
        	    // src/C.g:
        	    {
        	        if ( LA(1) == '$' || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleIDENTIFIEREx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDENTIFIEREx; /* Prevent compiler warnings */
    ruleIDENTIFIEREx: ;

}
// $ANTLR end IDENTIFIER

//   Comes from: 2428:5: ( '$' | 'A' .. 'Z' | 'a' .. 'z' | '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LETTER
 *
 * Looks to match the characters the constitute the token LETTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLETTER(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // src/C.g:2428:5: ( '$' | 'A' .. 'Z' | 'a' .. 'z' | '_' )
    // src/C.g:
    {
        if ( LA(1) == '$' || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLETTEREx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleLETTEREx; /* Prevent compiler warnings */
    ruleLETTEREx: ;

}
// $ANTLR end LETTER

//   Comes from: 2435:5: ( '\\'' ( EscapeSequence | ~ ( '\\'' | '\\\\' ) ) '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHARACTER_LITERAL
 *
 * Looks to match the characters the constitute the token CHARACTER_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCHARACTER_LITERAL(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = CHARACTER_LITERAL;
       
    
    // src/C.g:2435:5: ( '\\'' ( EscapeSequence | ~ ( '\\'' | '\\\\' ) ) '\\'' )
    // src/C.g:2435:9: '\\'' ( EscapeSequence | ~ ( '\\'' | '\\\\' ) ) '\\''
    {
        MATCHC('\''); 


        // src/C.g:2435:14: ( EscapeSequence | ~ ( '\\'' | '\\\\' ) )
        {
            int alt2=2;

            {
                int LA2_0 = LA(1);
                if ( (LA2_0 == '\\') ) 
                {
                    alt2=1;
                }
                else if ( (((LA2_0 >= 0x0000) && (LA2_0 <= '&')) || ((LA2_0 >= '(') && (LA2_0 <= '[')) || ((LA2_0 >= ']') && (LA2_0 <= 0xFFFE))) ) 
                {
                    alt2=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "2435:14: ( EscapeSequence | ~ ( '\\'' | '\\\\' ) )";
                    EXCEPTION->decisionNum  = 2;
                    EXCEPTION->state        = 0;

                
                    goto ruleCHARACTER_LITERALEx;
                }
            }
            switch (alt2) 
            {
        	case 1:
        	    // src/C.g:2435:16: EscapeSequence
        	    {
        	        /* 2435:16: EscapeSequence */
        	        mEscapeSequence(ctx ); 


        	    }
        	    break;
        	case 2:
        	    // src/C.g:2435:33: ~ ( '\\'' | '\\\\' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleCHARACTER_LITERALEx;
        	        }


        	    }
        	    break;

            }
        }
        MATCHC('\''); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCHARACTER_LITERALEx; /* Prevent compiler warnings */
    ruleCHARACTER_LITERALEx: ;

}
// $ANTLR end CHARACTER_LITERAL

//   Comes from: 2439:5: ( '\"' STRING_GUTS '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL
 *
 * Looks to match the characters the constitute the token STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = STRING_LITERAL;
       
    
    // src/C.g:2439:5: ( '\"' STRING_GUTS '\"' )
    // src/C.g:2439:8: '\"' STRING_GUTS '\"'
    {
        MATCHC('"'); 

        /* 2439:8: '\"' STRING_GUTS '\"' */
        mSTRING_GUTS(ctx ); 

        MATCHC('"'); 


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleSTRING_LITERALEx: ;

}
// $ANTLR end STRING_LITERAL

//   Comes from: 2443:13: ( ( EscapeSequence | ~ ( '\\\\' | '\"' ) )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_GUTS
 *
 * Looks to match the characters the constitute the token STRING_GUTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_GUTS(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // src/C.g:2443:13: ( ( EscapeSequence | ~ ( '\\\\' | '\"' ) )* )
    // src/C.g:2443:17: ( EscapeSequence | ~ ( '\\\\' | '\"' ) )*
    {

        // src/C.g:2443:17: ( EscapeSequence | ~ ( '\\\\' | '\"' ) )*

        for (;;)
        {
            int alt3=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = LA(1);
                if ( (LA3_0 == '\\') ) 
                {
                    alt3=1;
                }
                else if ( (((LA3_0 >= 0x0000) && (LA3_0 <= '!')) || ((LA3_0 >= '#') && (LA3_0 <= '[')) || ((LA3_0 >= ']') && (LA3_0 <= 0xFFFE))) ) 
                {
                    alt3=2;
                }

            }
            switch (alt3) 
            {
        	case 1:
        	    // src/C.g:2443:19: EscapeSequence
        	    {
        	        /* 2443:19: EscapeSequence */
        	        mEscapeSequence(ctx ); 


        	    }
        	    break;
        	case 2:
        	    // src/C.g:2443:36: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSTRING_GUTSEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */


    }



    // This is where rules clean up and exit
    //
    goto ruleSTRING_GUTSEx; /* Prevent compiler warnings */
    ruleSTRING_GUTSEx: ;

}
// $ANTLR end STRING_GUTS

//   Comes from: 2445:13: ( '0' ( 'x' | 'X' ) ( HexDigit )+ ( IntegerTypeSuffix )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_LITERAL
 *
 * Looks to match the characters the constitute the token HEX_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_LITERAL(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = HEX_LITERAL;
       
    
    // src/C.g:2445:13: ( '0' ( 'x' | 'X' ) ( HexDigit )+ ( IntegerTypeSuffix )? )
    // src/C.g:2445:15: '0' ( 'x' | 'X' ) ( HexDigit )+ ( IntegerTypeSuffix )?
    {
        MATCHC('0'); 

        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_LITERALEx;
        }

        // src/C.g:2445:29: ( HexDigit )+
        {
            int cnt4=0;

            for (;;)
            {
                int alt4=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA4_0 = LA(1);
        	    if ( (((LA4_0 >= '0') && (LA4_0 <= '9')) || ((LA4_0 >= 'A') && (LA4_0 <= 'F')) || ((LA4_0 >= 'a') && (LA4_0 <= 'f'))) ) 
        	    {
        	        alt4=1;
        	    }

        	}
        	switch (alt4) 
        	{
        	    case 1:
        	        // src/C.g:2445:29: HexDigit
        	        {
        	            /* 2445:29: HexDigit */
        	            mHexDigit(ctx ); 


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt4 >= 1 )
        		{
        		    goto loop4;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleHEX_LITERALEx;
        	}
        	cnt4++;
            }
            loop4: ;	/* Jump to here if this rule does not match */
        }

        // src/C.g:2445:39: ( IntegerTypeSuffix )?
        {
            int alt5=2;
            {
                int LA5_0 = LA(1);
                if ( (LA5_0 == 'L' || LA5_0 == 'U' || LA5_0 == 'l' || LA5_0 == 'u') ) 
                {
                    alt5=1;
                }
            }
            switch (alt5) 
            {
        	case 1:
        	    // src/C.g:2445:39: IntegerTypeSuffix
        	    {
        	        /* 2445:39: IntegerTypeSuffix */
        	        mIntegerTypeSuffix(ctx ); 


        	    }
        	    break;

            }
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleHEX_LITERALEx; /* Prevent compiler warnings */
    ruleHEX_LITERALEx: ;

}
// $ANTLR end HEX_LITERAL

//   Comes from: 2447:17: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) ( IntegerTypeSuffix )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_LITERAL(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = DECIMAL_LITERAL;
       
    
    // src/C.g:2447:17: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) ( IntegerTypeSuffix )? )
    // src/C.g:2447:19: ( '0' | '1' .. '9' ( '0' .. '9' )* ) ( IntegerTypeSuffix )?
    {

        // src/C.g:2447:19: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        {
            int alt7=2;

            {
                int LA7_0 = LA(1);
                if ( (LA7_0 == '0') ) 
                {
                    alt7=1;
                }
                else if ( (((LA7_0 >= '1') && (LA7_0 <= '9'))) ) 
                {
                    alt7=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "2447:19: ( '0' | '1' .. '9' ( '0' .. '9' )* )";
                    EXCEPTION->decisionNum  = 7;
                    EXCEPTION->state        = 0;

                
                    goto ruleDECIMAL_LITERALEx;
                }
            }
            switch (alt7) 
            {
        	case 1:
        	    // src/C.g:2447:20: '0'
        	    {
        	        MATCHC('0'); 


        	    }
        	    break;
        	case 2:
        	    // src/C.g:2447:26: '1' .. '9' ( '0' .. '9' )*
        	    {
        	        MATCHRANGE('1', '9'); 


        	        // src/C.g:2447:35: ( '0' .. '9' )*

        	        for (;;)
        	        {
        	            int alt6=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA6_0 = LA(1);
        	                if ( (((LA6_0 >= '0') && (LA6_0 <= '9'))) ) 
        	                {
        	                    alt6=1;
        	                }

        	            }
        	            switch (alt6) 
        	            {
        	        	case 1:
        	        	    // src/C.g:2447:35: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop6;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop6: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }

        // src/C.g:2447:46: ( IntegerTypeSuffix )?
        {
            int alt8=2;
            {
                int LA8_0 = LA(1);
                if ( (LA8_0 == 'L' || LA8_0 == 'U' || LA8_0 == 'l' || LA8_0 == 'u') ) 
                {
                    alt8=1;
                }
            }
            switch (alt8) 
            {
        	case 1:
        	    // src/C.g:2447:46: IntegerTypeSuffix
        	    {
        	        /* 2447:46: IntegerTypeSuffix */
        	        mIntegerTypeSuffix(ctx ); 


        	    }
        	    break;

            }
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_LITERALEx: ;

}
// $ANTLR end DECIMAL_LITERAL

//   Comes from: 2449:15: ( '0' ( '0' .. '7' )+ ( IntegerTypeSuffix )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_LITERAL
 *
 * Looks to match the characters the constitute the token OCTAL_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_LITERAL(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = OCTAL_LITERAL;
       
    
    // src/C.g:2449:15: ( '0' ( '0' .. '7' )+ ( IntegerTypeSuffix )? )
    // src/C.g:2449:17: '0' ( '0' .. '7' )+ ( IntegerTypeSuffix )?
    {
        MATCHC('0'); 

        // src/C.g:2449:21: ( '0' .. '7' )+
        {
            int cnt9=0;

            for (;;)
            {
                int alt9=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA9_0 = LA(1);
        	    if ( (((LA9_0 >= '0') && (LA9_0 <= '7'))) ) 
        	    {
        	        alt9=1;
        	    }

        	}
        	switch (alt9) 
        	{
        	    case 1:
        	        // src/C.g:2449:22: '0' .. '7'
        	        {
        	            MATCHRANGE('0', '7'); 


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt9 >= 1 )
        		{
        		    goto loop9;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleOCTAL_LITERALEx;
        	}
        	cnt9++;
            }
            loop9: ;	/* Jump to here if this rule does not match */
        }

        // src/C.g:2449:33: ( IntegerTypeSuffix )?
        {
            int alt10=2;
            {
                int LA10_0 = LA(1);
                if ( (LA10_0 == 'L' || LA10_0 == 'U' || LA10_0 == 'l' || LA10_0 == 'u') ) 
                {
                    alt10=1;
                }
            }
            switch (alt10) 
            {
        	case 1:
        	    // src/C.g:2449:33: IntegerTypeSuffix
        	    {
        	        /* 2449:33: IntegerTypeSuffix */
        	        mIntegerTypeSuffix(ctx ); 


        	    }
        	    break;

            }
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleOCTAL_LITERALEx; /* Prevent compiler warnings */
    ruleOCTAL_LITERALEx: ;

}
// $ANTLR end OCTAL_LITERAL

//   Comes from: 2452:10: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HexDigit
 *
 * Looks to match the characters the constitute the token HexDigit
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHexDigit(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // src/C.g:2452:10: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
    // src/C.g:2452:12: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHexDigitEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHexDigitEx; /* Prevent compiler warnings */
    ruleHexDigitEx: ;

}
// $ANTLR end HexDigit

//   Comes from: 2456:5: ( ( 'l' | 'L' ) ( 'l' | 'L' )? | ( 'u' | 'U' ) ( ( 'l' | 'L' ) ( 'l' | 'L' )? )? | ( 'l' | 'L' ) ( 'l' | 'L' )? ( 'u' | 'U' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IntegerTypeSuffix
 *
 * Looks to match the characters the constitute the token IntegerTypeSuffix
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIntegerTypeSuffix(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  src/C.g:2456:5: ( ( 'l' | 'L' ) ( 'l' | 'L' )? | ( 'u' | 'U' ) ( ( 'l' | 'L' ) ( 'l' | 'L' )? )? | ( 'l' | 'L' ) ( 'l' | 'L' )? ( 'u' | 'U' ) )
        
        ANTLR3_UINT32 alt15;

        alt15=3;


        {
            int LA15_0 = LA(1);
            if ( (LA15_0 == 'L' || LA15_0 == 'l') ) 
            {
                switch ( LA(2) ) 
                {
                case 'L':
                case 'l':
                	{

                		{
                		    int LA15_3 = LA(3);
                		    if ( (LA15_3 == 'U' || LA15_3 == 'u') ) 
                		    {
                		        alt15=3;
                		    }
                		    else 
                		    {
                		        alt15=1;    }
                		}
                	}
                    break;
                case 'U':
                case 'u':
                	{
                		alt15=3;
                	}
                    break;

                default:
                    alt15=1;}

            }
            else if ( (LA15_0 == 'U' || LA15_0 == 'u') ) 
            {
                alt15=2;
            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "2454:1: fragment IntegerTypeSuffix : ( ( 'l' | 'L' ) ( 'l' | 'L' )? | ( 'u' | 'U' ) ( ( 'l' | 'L' ) ( 'l' | 'L' )? )? | ( 'l' | 'L' ) ( 'l' | 'L' )? ( 'u' | 'U' ) );";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;

            
                goto ruleIntegerTypeSuffixEx;
            }
        }
        switch (alt15) 
        {
    	case 1:
    	    // src/C.g:2456:9: ( 'l' | 'L' ) ( 'l' | 'L' )?
    	    {
    	        if ( LA(1) == 'L' || LA(1) == 'l' )
    	        {
    	            CONSUME();

    	        }
    	        else 
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleIntegerTypeSuffixEx;
    	        }


    	        // src/C.g:2456:19: ( 'l' | 'L' )?
    	        {
    	            int alt11=2;
    	            {
    	                int LA11_0 = LA(1);
    	                if ( (LA11_0 == 'L' || LA11_0 == 'l') ) 
    	                {
    	                    alt11=1;
    	                }
    	            }
    	            switch (alt11) 
    	            {
    	        	case 1:
    	        	    // src/C.g:
    	        	    {
    	        	        if ( LA(1) == 'L' || LA(1) == 'l' )
    	        	        {
    	        	            CONSUME();

    	        	        }
    	        	        else 
    	        	        {
    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();    goto ruleIntegerTypeSuffixEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // src/C.g:2457:9: ( 'u' | 'U' ) ( ( 'l' | 'L' ) ( 'l' | 'L' )? )?
    	    {
    	        if ( LA(1) == 'U' || LA(1) == 'u' )
    	        {
    	            CONSUME();

    	        }
    	        else 
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleIntegerTypeSuffixEx;
    	        }


    	        // src/C.g:2457:20: ( ( 'l' | 'L' ) ( 'l' | 'L' )? )?
    	        {
    	            int alt13=2;
    	            {
    	                int LA13_0 = LA(1);
    	                if ( (LA13_0 == 'L' || LA13_0 == 'l') ) 
    	                {
    	                    alt13=1;
    	                }
    	            }
    	            switch (alt13) 
    	            {
    	        	case 1:
    	        	    // src/C.g:2457:21: ( 'l' | 'L' ) ( 'l' | 'L' )?
    	        	    {
    	        	        if ( LA(1) == 'L' || LA(1) == 'l' )
    	        	        {
    	        	            CONSUME();

    	        	        }
    	        	        else 
    	        	        {
    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();    goto ruleIntegerTypeSuffixEx;
    	        	        }


    	        	        // src/C.g:2457:31: ( 'l' | 'L' )?
    	        	        {
    	        	            int alt12=2;
    	        	            {
    	        	                int LA12_0 = LA(1);
    	        	                if ( (LA12_0 == 'L' || LA12_0 == 'l') ) 
    	        	                {
    	        	                    alt12=1;
    	        	                }
    	        	            }
    	        	            switch (alt12) 
    	        	            {
    	        	        	case 1:
    	        	        	    // src/C.g:
    	        	        	    {
    	        	        	        if ( LA(1) == 'L' || LA(1) == 'l' )
    	        	        	        {
    	        	        	            CONSUME();

    	        	        	        }
    	        	        	        else 
    	        	        	        {
    	        	        	            CONSTRUCTEX();
    	        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	        	        	            LRECOVER();    goto ruleIntegerTypeSuffixEx;
    	        	        	        }


    	        	        	    }
    	        	        	    break;

    	        	            }
    	        	        }

    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 3:
    	    // src/C.g:2458:9: ( 'l' | 'L' ) ( 'l' | 'L' )? ( 'u' | 'U' )
    	    {
    	        if ( LA(1) == 'L' || LA(1) == 'l' )
    	        {
    	            CONSUME();

    	        }
    	        else 
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleIntegerTypeSuffixEx;
    	        }


    	        // src/C.g:2458:19: ( 'l' | 'L' )?
    	        {
    	            int alt14=2;
    	            {
    	                int LA14_0 = LA(1);
    	                if ( (LA14_0 == 'L' || LA14_0 == 'l') ) 
    	                {
    	                    alt14=1;
    	                }
    	            }
    	            switch (alt14) 
    	            {
    	        	case 1:
    	        	    // src/C.g:
    	        	    {
    	        	        if ( LA(1) == 'L' || LA(1) == 'l' )
    	        	        {
    	        	            CONSUME();

    	        	        }
    	        	        else 
    	        	        {
    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();    goto ruleIntegerTypeSuffixEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }
    	        if ( LA(1) == 'U' || LA(1) == 'u' )
    	        {
    	            CONSUME();

    	        }
    	        else 
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleIntegerTypeSuffixEx;
    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleIntegerTypeSuffixEx; /* Prevent compiler warnings */
    ruleIntegerTypeSuffixEx: ;

}
// $ANTLR end IntegerTypeSuffix

//   Comes from: 2462:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? ( FloatTypeSuffix )? | '.' ( '0' .. '9' )+ ( Exponent )? ( FloatTypeSuffix )? | ( '0' .. '9' )+ ( Exponent ( FloatTypeSuffix )? | FloatTypeSuffix ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOATING_POINT_LITERAL
 *
 * Looks to match the characters the constitute the token FLOATING_POINT_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOATING_POINT_LITERAL(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = FLOATING_POINT_LITERAL;
       
    
    {
        //  src/C.g:2462:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? ( FloatTypeSuffix )? | '.' ( '0' .. '9' )+ ( Exponent )? ( FloatTypeSuffix )? | ( '0' .. '9' )+ ( Exponent ( FloatTypeSuffix )? | FloatTypeSuffix ) )
        
        ANTLR3_UINT32 alt26;

        alt26=3;

        alt26 = cdfa26.predict(ctx, RECOGNIZER, INPUT->istream, &cdfa26);
        switch (alt26) 
        {
    	case 1:
    	    // src/C.g:2462:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? ( FloatTypeSuffix )?
    	    {
    	        // src/C.g:2462:9: ( '0' .. '9' )+
    	        {
    	            int cnt16=0;

    	            for (;;)
    	            {
    	                int alt16=2;
    	        	{
    	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	        	    */
    	        	    int LA16_0 = LA(1);
    	        	    if ( (((LA16_0 >= '0') && (LA16_0 <= '9'))) ) 
    	        	    {
    	        	        alt16=1;
    	        	    }

    	        	}
    	        	switch (alt16) 
    	        	{
    	        	    case 1:
    	        	        // src/C.g:2462:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt16 >= 1 )
    	        		{
    	        		    goto loop16;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt16++;
    	            }
    	            loop16: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 


    	        // src/C.g:2462:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt17=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA17_0 = LA(1);
    	                if ( (((LA17_0 >= '0') && (LA17_0 <= '9'))) ) 
    	                {
    	                    alt17=1;
    	                }

    	            }
    	            switch (alt17) 
    	            {
    	        	case 1:
    	        	    // src/C.g:2462:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop17;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop17: ; /* Jump out to here if this rule does not match */


    	        // src/C.g:2462:37: ( Exponent )?
    	        {
    	            int alt18=2;
    	            {
    	                int LA18_0 = LA(1);
    	                if ( (LA18_0 == 'E' || LA18_0 == 'e') ) 
    	                {
    	                    alt18=1;
    	                }
    	            }
    	            switch (alt18) 
    	            {
    	        	case 1:
    	        	    // src/C.g:2462:37: Exponent
    	        	    {
    	        	        /* 2462:37: Exponent */
    	        	        mExponent(ctx ); 


    	        	    }
    	        	    break;

    	            }
    	        }

    	        // src/C.g:2462:47: ( FloatTypeSuffix )?
    	        {
    	            int alt19=2;
    	            {
    	                int LA19_0 = LA(1);
    	                if ( (LA19_0 == 'D' || LA19_0 == 'F' || LA19_0 == 'd' || LA19_0 == 'f') ) 
    	                {
    	                    alt19=1;
    	                }
    	            }
    	            switch (alt19) 
    	            {
    	        	case 1:
    	        	    // src/C.g:2462:47: FloatTypeSuffix
    	        	    {
    	        	        /* 2462:47: FloatTypeSuffix */
    	        	        mFloatTypeSuffix(ctx ); 


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // src/C.g:2463:9: '.' ( '0' .. '9' )+ ( Exponent )? ( FloatTypeSuffix )?
    	    {
    	        MATCHC('.'); 

    	        // src/C.g:2463:13: ( '0' .. '9' )+
    	        {
    	            int cnt20=0;

    	            for (;;)
    	            {
    	                int alt20=2;
    	        	{
    	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	        	    */
    	        	    int LA20_0 = LA(1);
    	        	    if ( (((LA20_0 >= '0') && (LA20_0 <= '9'))) ) 
    	        	    {
    	        	        alt20=1;
    	        	    }

    	        	}
    	        	switch (alt20) 
    	        	{
    	        	    case 1:
    	        	        // src/C.g:2463:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt20 >= 1 )
    	        		{
    	        		    goto loop20;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt20++;
    	            }
    	            loop20: ;	/* Jump to here if this rule does not match */
    	        }

    	        // src/C.g:2463:25: ( Exponent )?
    	        {
    	            int alt21=2;
    	            {
    	                int LA21_0 = LA(1);
    	                if ( (LA21_0 == 'E' || LA21_0 == 'e') ) 
    	                {
    	                    alt21=1;
    	                }
    	            }
    	            switch (alt21) 
    	            {
    	        	case 1:
    	        	    // src/C.g:2463:25: Exponent
    	        	    {
    	        	        /* 2463:25: Exponent */
    	        	        mExponent(ctx ); 


    	        	    }
    	        	    break;

    	            }
    	        }

    	        // src/C.g:2463:35: ( FloatTypeSuffix )?
    	        {
    	            int alt22=2;
    	            {
    	                int LA22_0 = LA(1);
    	                if ( (LA22_0 == 'D' || LA22_0 == 'F' || LA22_0 == 'd' || LA22_0 == 'f') ) 
    	                {
    	                    alt22=1;
    	                }
    	            }
    	            switch (alt22) 
    	            {
    	        	case 1:
    	        	    // src/C.g:2463:35: FloatTypeSuffix
    	        	    {
    	        	        /* 2463:35: FloatTypeSuffix */
    	        	        mFloatTypeSuffix(ctx ); 


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 3:
    	    // src/C.g:2464:9: ( '0' .. '9' )+ ( Exponent ( FloatTypeSuffix )? | FloatTypeSuffix )
    	    {
    	        // src/C.g:2464:9: ( '0' .. '9' )+
    	        {
    	            int cnt23=0;

    	            for (;;)
    	            {
    	                int alt23=2;
    	        	{
    	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	        	    */
    	        	    int LA23_0 = LA(1);
    	        	    if ( (((LA23_0 >= '0') && (LA23_0 <= '9'))) ) 
    	        	    {
    	        	        alt23=1;
    	        	    }

    	        	}
    	        	switch (alt23) 
    	        	{
    	        	    case 1:
    	        	        // src/C.g:2464:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt23 >= 1 )
    	        		{
    	        		    goto loop23;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt23++;
    	            }
    	            loop23: ;	/* Jump to here if this rule does not match */
    	        }

    	        // src/C.g:2464:21: ( Exponent ( FloatTypeSuffix )? | FloatTypeSuffix )
    	        {
    	            int alt25=2;

    	            {
    	                int LA25_0 = LA(1);
    	                if ( (LA25_0 == 'E' || LA25_0 == 'e') ) 
    	                {
    	                    alt25=1;
    	                }
    	                else if ( (LA25_0 == 'D' || LA25_0 == 'F' || LA25_0 == 'd' || LA25_0 == 'f') ) 
    	                {
    	                    alt25=2;
    	                }
    	                else 
    	                {
    	                
    	                    CONSTRUCTEX();
    	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    	                    EXCEPTION->message      = "2464:21: ( Exponent ( FloatTypeSuffix )? | FloatTypeSuffix )";
    	                    EXCEPTION->decisionNum  = 25;
    	                    EXCEPTION->state        = 0;

    	                
    	                    goto ruleFLOATING_POINT_LITERALEx;
    	                }
    	            }
    	            switch (alt25) 
    	            {
    	        	case 1:
    	        	    // src/C.g:2464:23: Exponent ( FloatTypeSuffix )?
    	        	    {
    	        	        /* 2464:23: Exponent ( FloatTypeSuffix )? */
    	        	        mExponent(ctx ); 


    	        	        // src/C.g:2464:32: ( FloatTypeSuffix )?
    	        	        {
    	        	            int alt24=2;
    	        	            {
    	        	                int LA24_0 = LA(1);
    	        	                if ( (LA24_0 == 'D' || LA24_0 == 'F' || LA24_0 == 'd' || LA24_0 == 'f') ) 
    	        	                {
    	        	                    alt24=1;
    	        	                }
    	        	            }
    	        	            switch (alt24) 
    	        	            {
    	        	        	case 1:
    	        	        	    // src/C.g:2464:32: FloatTypeSuffix
    	        	        	    {
    	        	        	        /* 2464:32: FloatTypeSuffix */
    	        	        	        mFloatTypeSuffix(ctx ); 


    	        	        	    }
    	        	        	    break;

    	        	            }
    	        	        }

    	        	    }
    	        	    break;
    	        	case 2:
    	        	    // src/C.g:2464:51: FloatTypeSuffix
    	        	    {
    	        	        /* 2464:51: FloatTypeSuffix */
    	        	        mFloatTypeSuffix(ctx ); 


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;

        }
    }
	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATING_POINT_LITERALEx; /* Prevent compiler warnings */
    ruleFLOATING_POINT_LITERALEx: ;

}
// $ANTLR end FLOATING_POINT_LITERAL

//   Comes from: 2468:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start Exponent
 *
 * Looks to match the characters the constitute the token Exponent
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mExponent(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // src/C.g:2468:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // src/C.g:2468:12: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleExponentEx;
        }


        // src/C.g:2468:22: ( '+' | '-' )?
        {
            int alt27=2;
            {
                int LA27_0 = LA(1);
                if ( (LA27_0 == '+' || LA27_0 == '-') ) 
                {
                    alt27=1;
                }
            }
            switch (alt27) 
            {
        	case 1:
        	    // src/C.g:
        	    {
        	        if ( LA(1) == '+' || LA(1) == '-' )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleExponentEx;
        	        }


        	    }
        	    break;

            }
        }
        // src/C.g:2468:33: ( '0' .. '9' )+
        {
            int cnt28=0;

            for (;;)
            {
                int alt28=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA28_0 = LA(1);
        	    if ( (((LA28_0 >= '0') && (LA28_0 <= '9'))) ) 
        	    {
        	        alt28=1;
        	    }

        	}
        	switch (alt28) 
        	{
        	    case 1:
        	        // src/C.g:2468:34: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt28 >= 1 )
        		{
        		    goto loop28;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleExponentEx;
        	}
        	cnt28++;
            }
            loop28: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleExponentEx; /* Prevent compiler warnings */
    ruleExponentEx: ;

}
// $ANTLR end Exponent

//   Comes from: 2471:17: ( ( 'f' | 'F' | 'd' | 'D' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FloatTypeSuffix
 *
 * Looks to match the characters the constitute the token FloatTypeSuffix
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFloatTypeSuffix(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // src/C.g:2471:17: ( ( 'f' | 'F' | 'd' | 'D' ) )
    // src/C.g:2471:19: ( 'f' | 'F' | 'd' | 'D' )
    {
        if ( LA(1) == 'D' || LA(1) == 'F' || LA(1) == 'd' || LA(1) == 'f' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleFloatTypeSuffixEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleFloatTypeSuffixEx; /* Prevent compiler warnings */
    ruleFloatTypeSuffixEx: ;

}
// $ANTLR end FloatTypeSuffix

//   Comes from: 2475:5: ( '\\\\' ( 'a' | 'b' | 't' | 'n' | 'f' | 'r' | 'e' | 'E' | 'v' | '\\\"' | '\\'' | '\\\\' ) | OctalEscape | HexEscape | UnicodeEscape )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EscapeSequence
 *
 * Looks to match the characters the constitute the token EscapeSequence
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEscapeSequence(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  src/C.g:2475:5: ( '\\\\' ( 'a' | 'b' | 't' | 'n' | 'f' | 'r' | 'e' | 'E' | 'v' | '\\\"' | '\\'' | '\\\\' ) | OctalEscape | HexEscape | UnicodeEscape )
        
        ANTLR3_UINT32 alt29;

        alt29=4;


        {
            int LA29_0 = LA(1);
            if ( (LA29_0 == '\\') ) 
            {
                switch ( LA(2) ) 
                {
                case 'U':
                case 'u':
                	{
                		alt29=4;
                	}
                    break;
                case '"':
                case '\'':
                case 'E':
                case '\\':
                case 'a':
                case 'b':
                case 'e':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                case 'v':
                	{
                		alt29=1;
                	}
                    break;
                case 'x':
                	{
                		alt29=3;
                	}
                    break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                	{
                		alt29=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = "2473:1: fragment EscapeSequence : ( '\\\\' ( 'a' | 'b' | 't' | 'n' | 'f' | 'r' | 'e' | 'E' | 'v' | '\\\"' | '\\'' | '\\\\' ) | OctalEscape | HexEscape | UnicodeEscape );";
                    EXCEPTION->decisionNum  = 29;
                    EXCEPTION->state        = 1;


                    goto ruleEscapeSequenceEx;
                }

            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "2473:1: fragment EscapeSequence : ( '\\\\' ( 'a' | 'b' | 't' | 'n' | 'f' | 'r' | 'e' | 'E' | 'v' | '\\\"' | '\\'' | '\\\\' ) | OctalEscape | HexEscape | UnicodeEscape );";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;

            
                goto ruleEscapeSequenceEx;
            }
        }
        switch (alt29) 
        {
    	case 1:
    	    // src/C.g:2475:9: '\\\\' ( 'a' | 'b' | 't' | 'n' | 'f' | 'r' | 'e' | 'E' | 'v' | '\\\"' | '\\'' | '\\\\' )
    	    {
    	        MATCHC('\\'); 

    	        if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == 'E' || LA(1) == '\\' || ((LA(1) >= 'a') && (LA(1) <= 'b')) || ((LA(1) >= 'e') && (LA(1) <= 'f')) || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' || LA(1) == 'v' )
    	        {
    	            CONSUME();

    	        }
    	        else 
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleEscapeSequenceEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // src/C.g:2476:9: OctalEscape
    	    {
    	        /* 2476:9: OctalEscape */
    	        mOctalEscape(ctx ); 


    	    }
    	    break;
    	case 3:
    	    // src/C.g:2477:9: HexEscape
    	    {
    	        /* 2477:9: HexEscape */
    	        mHexEscape(ctx ); 


    	    }
    	    break;
    	case 4:
    	    // src/C.g:2478:9: UnicodeEscape
    	    {
    	        /* 2478:9: UnicodeEscape */
    	        mUnicodeEscape(ctx ); 


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleEscapeSequenceEx; /* Prevent compiler warnings */
    ruleEscapeSequenceEx: ;

}
// $ANTLR end EscapeSequence

//   Comes from: 2483:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OctalEscape
 *
 * Looks to match the characters the constitute the token OctalEscape
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOctalEscape(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  src/C.g:2483:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
        
        ANTLR3_UINT32 alt30;

        alt30=3;


        {
            int LA30_0 = LA(1);
            if ( (LA30_0 == '\\') ) 
            {

                {
                    int LA30_1 = LA(2);
                    if ( (((LA30_1 >= '0') && (LA30_1 <= '3'))) ) 
                    {

                        {
                            int LA30_2 = LA(3);
                            if ( (((LA30_2 >= '0') && (LA30_2 <= '7'))) ) 
                            {

                                {
                                    int LA30_4 = LA(4);
                                    if ( (((LA30_4 >= '0') && (LA30_4 <= '7'))) ) 
                                    {
                                        alt30=1;
                                    }
                                    else 
                                    {
                                        alt30=2;    }
                                }
                            }
                            else 
                            {
                                alt30=3;    }
                        }
                    }
                    else if ( (((LA30_1 >= '4') && (LA30_1 <= '7'))) ) 
                    {

                        {
                            int LA30_3 = LA(3);
                            if ( (((LA30_3 >= '0') && (LA30_3 <= '7'))) ) 
                            {
                                alt30=2;
                            }
                            else 
                            {
                                alt30=3;    }
                        }
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "2481:1: fragment OctalEscape : ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) );";
                        EXCEPTION->decisionNum  = 30;
                        EXCEPTION->state        = 1;

                    
                        goto ruleOctalEscapeEx;
                    }
                }
            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "2481:1: fragment OctalEscape : ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) );";
                EXCEPTION->decisionNum  = 30;
                EXCEPTION->state        = 0;

            
                goto ruleOctalEscapeEx;
            }
        }
        switch (alt30) 
        {
    	case 1:
    	    // src/C.g:2483:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 

    	        // src/C.g:2483:14: ( '0' .. '3' )
    	        // src/C.g:2483:15: '0' .. '3'
    	        {
    	            MATCHRANGE('0', '3'); 


    	        }

    	        // src/C.g:2483:25: ( '0' .. '7' )
    	        // src/C.g:2483:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 


    	        }

    	        // src/C.g:2483:36: ( '0' .. '7' )
    	        // src/C.g:2483:37: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 


    	        }


    	    }
    	    break;
    	case 2:
    	    // src/C.g:2484:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 

    	        // src/C.g:2484:14: ( '0' .. '7' )
    	        // src/C.g:2484:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 


    	        }

    	        // src/C.g:2484:25: ( '0' .. '7' )
    	        // src/C.g:2484:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 


    	        }


    	    }
    	    break;
    	case 3:
    	    // src/C.g:2485:9: '\\\\' ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 

    	        // src/C.g:2485:14: ( '0' .. '7' )
    	        // src/C.g:2485:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 


    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleOctalEscapeEx; /* Prevent compiler warnings */
    ruleOctalEscapeEx: ;

}
// $ANTLR end OctalEscape

//   Comes from: 2490:5: ( '\\\\' 'x' ( HexDigit )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HexEscape
 *
 * Looks to match the characters the constitute the token HexEscape
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHexEscape(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // src/C.g:2490:5: ( '\\\\' 'x' ( HexDigit )+ )
    // src/C.g:2490:9: '\\\\' 'x' ( HexDigit )+
    {
        MATCHC('\\'); 

        MATCHC('x'); 

        // src/C.g:2490:18: ( HexDigit )+
        {
            int cnt31=0;

            for (;;)
            {
                int alt31=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA31_0 = LA(1);
        	    if ( (((LA31_0 >= '0') && (LA31_0 <= '9')) || ((LA31_0 >= 'A') && (LA31_0 <= 'F')) || ((LA31_0 >= 'a') && (LA31_0 <= 'f'))) ) 
        	    {
        	        alt31=1;
        	    }

        	}
        	switch (alt31) 
        	{
        	    case 1:
        	        // src/C.g:2490:18: HexDigit
        	        {
        	            /* 2490:18: HexDigit */
        	            mHexDigit(ctx ); 


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt31 >= 1 )
        		{
        		    goto loop31;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleHexEscapeEx;
        	}
        	cnt31++;
            }
            loop31: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleHexEscapeEx; /* Prevent compiler warnings */
    ruleHexEscapeEx: ;

}
// $ANTLR end HexEscape

//   Comes from: 2495:5: ( '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit | '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UnicodeEscape
 *
 * Looks to match the characters the constitute the token UnicodeEscape
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUnicodeEscape(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  src/C.g:2495:5: ( '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit | '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit )
        
        ANTLR3_UINT32 alt32;

        alt32=2;


        {
            int LA32_0 = LA(1);
            if ( (LA32_0 == '\\') ) 
            {

                {
                    int LA32_1 = LA(2);
                    if ( (LA32_1 == 'u') ) 
                    {
                        alt32=1;
                    }
                    else if ( (LA32_1 == 'U') ) 
                    {
                        alt32=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "2493:1: fragment UnicodeEscape : ( '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit | '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit );";
                        EXCEPTION->decisionNum  = 32;
                        EXCEPTION->state        = 1;

                    
                        goto ruleUnicodeEscapeEx;
                    }
                }
            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "2493:1: fragment UnicodeEscape : ( '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit | '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit );";
                EXCEPTION->decisionNum  = 32;
                EXCEPTION->state        = 0;

            
                goto ruleUnicodeEscapeEx;
            }
        }
        switch (alt32) 
        {
    	case 1:
    	    // src/C.g:2495:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit
    	    {
    	        MATCHC('\\'); 

    	        MATCHC('u'); 

    	        /* 2495:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2495:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2495:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2495:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 


    	    }
    	    break;
    	case 2:
    	    // src/C.g:2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
    	    {
    	        MATCHC('\\'); 

    	        MATCHC('U'); 

    	        /* 2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 

    	        /* 2496:9: '\\\\' 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit */
    	        mHexDigit(ctx ); 


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleUnicodeEscapeEx; /* Prevent compiler warnings */
    ruleUnicodeEscapeEx: ;

}
// $ANTLR end UnicodeEscape

//   Comes from: 2499:5: ( ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = WS;
       
    
    // src/C.g:2499:5: ( ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' ) )
    // src/C.g:2499:8: ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' )
    {
        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleWSEx;
        }

        {
            LEXER->channel=HIDDEN;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

//   Comes from: 2503:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = COMMENT;
       
    
    // src/C.g:2503:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
    // src/C.g:2503:9: '/*' ( options {greedy=false; } : . )* '*/'
    {
        MATCHS(lit_86); 



        // src/C.g:2503:14: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt33=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA33_0 = LA(1);
                if ( (LA33_0 == '*') ) 
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA33_1 = LA(2);
                        if ( (LA33_1 == '/') ) 
                        {
                            alt33=2;
                        }
                        else if ( (((LA33_1 >= 0x0000) && (LA33_1 <= '.')) || ((LA33_1 >= '0') && (LA33_1 <= 0xFFFE))) ) 
                        {
                            alt33=1;
                        }

                    }
                }
                else if ( (((LA33_0 >= 0x0000) && (LA33_0 <= ')')) || ((LA33_0 >= '+') && (LA33_0 <= 0xFFFE))) ) 
                {
                    alt33=1;
                }

            }
            switch (alt33) 
            {
        	case 1:
        	    // src/C.g:2503:42: .
        	    {
        	        MATCHANY(); 


        	    }
        	    break;

        	default:
        	    goto loop33;	/* break out of the loop */
        	    break;
            }
        }
        loop33: ; /* Jump out to here if this rule does not match */

        MATCHS(lit_87); 


        {
            LEXER->channel=HIDDEN;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 2507:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LINE_COMMENT
 *
 * Looks to match the characters the constitute the token LINE_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLINE_COMMENT(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LINE_COMMENT;
       
    
    // src/C.g:2507:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
    // src/C.g:2507:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    {
        MATCHS(lit_88); 



        // src/C.g:2507:12: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt34=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA34_0 = LA(1);
                if ( (((LA34_0 >= 0x0000) && (LA34_0 <= '\t')) || ((LA34_0 >= 0x000B) && (LA34_0 <= '\f')) || ((LA34_0 >= 0x000E) && (LA34_0 <= 0xFFFE))) ) 
                {
                    alt34=1;
                }

            }
            switch (alt34) 
            {
        	case 1:
        	    // src/C.g:2507:12: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleLINE_COMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop34;	/* break out of the loop */
        	    break;
            }
        }
        loop34: ; /* Jump out to here if this rule does not match */


        // src/C.g:2507:26: ( '\\r' )?
        {
            int alt35=2;
            {
                int LA35_0 = LA(1);
                if ( (LA35_0 == '\r') ) 
                {
                    alt35=1;
                }
            }
            switch (alt35) 
            {
        	case 1:
        	    // src/C.g:2507:26: '\\r'
        	    {
        	        MATCHC('\r'); 


        	    }
        	    break;

            }
        }
        MATCHC('\n'); 

        {
            LEXER->channel=HIDDEN;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLINE_COMMENTEx; /* Prevent compiler warnings */
    ruleLINE_COMMENTEx: ;

}
// $ANTLR end LINE_COMMENT

//   Comes from: 2512:5: ( '#' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LINE_COMMAND
 *
 * Looks to match the characters the constitute the token LINE_COMMAND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLINE_COMMAND(pCLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LINE_COMMAND;
       
    
    // src/C.g:2512:5: ( '#' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
    // src/C.g:2512:7: '#' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    {
        MATCHC('#'); 


        // src/C.g:2512:11: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt36=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA36_0 = LA(1);
                if ( (((LA36_0 >= 0x0000) && (LA36_0 <= '\t')) || ((LA36_0 >= 0x000B) && (LA36_0 <= '\f')) || ((LA36_0 >= 0x000E) && (LA36_0 <= 0xFFFE))) ) 
                {
                    alt36=1;
                }

            }
            switch (alt36) 
            {
        	case 1:
        	    // src/C.g:2512:11: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleLINE_COMMANDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop36;	/* break out of the loop */
        	    break;
            }
        }
        loop36: ; /* Jump out to here if this rule does not match */


        // src/C.g:2512:25: ( '\\r' )?
        {
            int alt37=2;
            {
                int LA37_0 = LA(1);
                if ( (LA37_0 == '\r') ) 
                {
                    alt37=1;
                }
            }
            switch (alt37) 
            {
        	case 1:
        	    // src/C.g:2512:25: '\\r'
        	    {
        	        MATCHC('\r'); 


        	    }
        	    break;

            }
        }
        MATCHC('\n'); 

        {
            LEXER->channel=HIDDEN;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLINE_COMMANDEx; /* Prevent compiler warnings */
    ruleLINE_COMMANDEx: ;

}
// $ANTLR end LINE_COMMAND

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pCLexer ctx)
{
    {
        //  src/C.g:1:8: ( T25 | T26 | T27 | T28 | T29 | T30 | T31 | T32 | T33 | T34 | T35 | T36 | T37 | T38 | T39 | T40 | T41 | T42 | T43 | T44 | T45 | T46 | T47 | T48 | T49 | T50 | T51 | T52 | T53 | T54 | T55 | T56 | T57 | T58 | T59 | T60 | T61 | T62 | T63 | T64 | T65 | T66 | T67 | T68 | T69 | T70 | T71 | T72 | T73 | T74 | T75 | T76 | T77 | T78 | T79 | T80 | T81 | T82 | T83 | T84 | T85 | T86 | T87 | T88 | T89 | T90 | T91 | T92 | T93 | T94 | T95 | T96 | T97 | T98 | T99 | T100 | T101 | T102 | T103 | T104 | T105 | T106 | T107 | T108 | T109 | T110 | T111 | T112 | T113 | T114 | T115 | T116 | T117 | T118 | T119 | T120 | T121 | T122 | T123 | T124 | T125 | T126 | T127 | T128 | T129 | T130 | T131 | T132 | T133 | IDENTIFIER | CHARACTER_LITERAL | STRING_LITERAL | HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOATING_POINT_LITERAL | WS | COMMENT | LINE_COMMENT | LINE_COMMAND )
        
        ANTLR3_UINT32 alt38;

        alt38=120;

        alt38 = cdfa38.predict(ctx, RECOGNIZER, INPUT->istream, &cdfa38);
        switch (alt38) 
        {
    	case 1:
    	    // src/C.g:1:10: T25
    	    {
    	        /* 1:10: T25 */
    	        mT25(ctx ); 


    	    }
    	    break;
    	case 2:
    	    // src/C.g:1:14: T26
    	    {
    	        /* 1:14: T26 */
    	        mT26(ctx ); 


    	    }
    	    break;
    	case 3:
    	    // src/C.g:1:18: T27
    	    {
    	        /* 1:18: T27 */
    	        mT27(ctx ); 


    	    }
    	    break;
    	case 4:
    	    // src/C.g:1:22: T28
    	    {
    	        /* 1:22: T28 */
    	        mT28(ctx ); 


    	    }
    	    break;
    	case 5:
    	    // src/C.g:1:26: T29
    	    {
    	        /* 1:26: T29 */
    	        mT29(ctx ); 


    	    }
    	    break;
    	case 6:
    	    // src/C.g:1:30: T30
    	    {
    	        /* 1:30: T30 */
    	        mT30(ctx ); 


    	    }
    	    break;
    	case 7:
    	    // src/C.g:1:34: T31
    	    {
    	        /* 1:34: T31 */
    	        mT31(ctx ); 


    	    }
    	    break;
    	case 8:
    	    // src/C.g:1:38: T32
    	    {
    	        /* 1:38: T32 */
    	        mT32(ctx ); 


    	    }
    	    break;
    	case 9:
    	    // src/C.g:1:42: T33
    	    {
    	        /* 1:42: T33 */
    	        mT33(ctx ); 


    	    }
    	    break;
    	case 10:
    	    // src/C.g:1:46: T34
    	    {
    	        /* 1:46: T34 */
    	        mT34(ctx ); 


    	    }
    	    break;
    	case 11:
    	    // src/C.g:1:50: T35
    	    {
    	        /* 1:50: T35 */
    	        mT35(ctx ); 


    	    }
    	    break;
    	case 12:
    	    // src/C.g:1:54: T36
    	    {
    	        /* 1:54: T36 */
    	        mT36(ctx ); 


    	    }
    	    break;
    	case 13:
    	    // src/C.g:1:58: T37
    	    {
    	        /* 1:58: T37 */
    	        mT37(ctx ); 


    	    }
    	    break;
    	case 14:
    	    // src/C.g:1:62: T38
    	    {
    	        /* 1:62: T38 */
    	        mT38(ctx ); 


    	    }
    	    break;
    	case 15:
    	    // src/C.g:1:66: T39
    	    {
    	        /* 1:66: T39 */
    	        mT39(ctx ); 


    	    }
    	    break;
    	case 16:
    	    // src/C.g:1:70: T40
    	    {
    	        /* 1:70: T40 */
    	        mT40(ctx ); 


    	    }
    	    break;
    	case 17:
    	    // src/C.g:1:74: T41
    	    {
    	        /* 1:74: T41 */
    	        mT41(ctx ); 


    	    }
    	    break;
    	case 18:
    	    // src/C.g:1:78: T42
    	    {
    	        /* 1:78: T42 */
    	        mT42(ctx ); 


    	    }
    	    break;
    	case 19:
    	    // src/C.g:1:82: T43
    	    {
    	        /* 1:82: T43 */
    	        mT43(ctx ); 


    	    }
    	    break;
    	case 20:
    	    // src/C.g:1:86: T44
    	    {
    	        /* 1:86: T44 */
    	        mT44(ctx ); 


    	    }
    	    break;
    	case 21:
    	    // src/C.g:1:90: T45
    	    {
    	        /* 1:90: T45 */
    	        mT45(ctx ); 


    	    }
    	    break;
    	case 22:
    	    // src/C.g:1:94: T46
    	    {
    	        /* 1:94: T46 */
    	        mT46(ctx ); 


    	    }
    	    break;
    	case 23:
    	    // src/C.g:1:98: T47
    	    {
    	        /* 1:98: T47 */
    	        mT47(ctx ); 


    	    }
    	    break;
    	case 24:
    	    // src/C.g:1:102: T48
    	    {
    	        /* 1:102: T48 */
    	        mT48(ctx ); 


    	    }
    	    break;
    	case 25:
    	    // src/C.g:1:106: T49
    	    {
    	        /* 1:106: T49 */
    	        mT49(ctx ); 


    	    }
    	    break;
    	case 26:
    	    // src/C.g:1:110: T50
    	    {
    	        /* 1:110: T50 */
    	        mT50(ctx ); 


    	    }
    	    break;
    	case 27:
    	    // src/C.g:1:114: T51
    	    {
    	        /* 1:114: T51 */
    	        mT51(ctx ); 


    	    }
    	    break;
    	case 28:
    	    // src/C.g:1:118: T52
    	    {
    	        /* 1:118: T52 */
    	        mT52(ctx ); 


    	    }
    	    break;
    	case 29:
    	    // src/C.g:1:122: T53
    	    {
    	        /* 1:122: T53 */
    	        mT53(ctx ); 


    	    }
    	    break;
    	case 30:
    	    // src/C.g:1:126: T54
    	    {
    	        /* 1:126: T54 */
    	        mT54(ctx ); 


    	    }
    	    break;
    	case 31:
    	    // src/C.g:1:130: T55
    	    {
    	        /* 1:130: T55 */
    	        mT55(ctx ); 


    	    }
    	    break;
    	case 32:
    	    // src/C.g:1:134: T56
    	    {
    	        /* 1:134: T56 */
    	        mT56(ctx ); 


    	    }
    	    break;
    	case 33:
    	    // src/C.g:1:138: T57
    	    {
    	        /* 1:138: T57 */
    	        mT57(ctx ); 


    	    }
    	    break;
    	case 34:
    	    // src/C.g:1:142: T58
    	    {
    	        /* 1:142: T58 */
    	        mT58(ctx ); 


    	    }
    	    break;
    	case 35:
    	    // src/C.g:1:146: T59
    	    {
    	        /* 1:146: T59 */
    	        mT59(ctx ); 


    	    }
    	    break;
    	case 36:
    	    // src/C.g:1:150: T60
    	    {
    	        /* 1:150: T60 */
    	        mT60(ctx ); 


    	    }
    	    break;
    	case 37:
    	    // src/C.g:1:154: T61
    	    {
    	        /* 1:154: T61 */
    	        mT61(ctx ); 


    	    }
    	    break;
    	case 38:
    	    // src/C.g:1:158: T62
    	    {
    	        /* 1:158: T62 */
    	        mT62(ctx ); 


    	    }
    	    break;
    	case 39:
    	    // src/C.g:1:162: T63
    	    {
    	        /* 1:162: T63 */
    	        mT63(ctx ); 


    	    }
    	    break;
    	case 40:
    	    // src/C.g:1:166: T64
    	    {
    	        /* 1:166: T64 */
    	        mT64(ctx ); 


    	    }
    	    break;
    	case 41:
    	    // src/C.g:1:170: T65
    	    {
    	        /* 1:170: T65 */
    	        mT65(ctx ); 


    	    }
    	    break;
    	case 42:
    	    // src/C.g:1:174: T66
    	    {
    	        /* 1:174: T66 */
    	        mT66(ctx ); 


    	    }
    	    break;
    	case 43:
    	    // src/C.g:1:178: T67
    	    {
    	        /* 1:178: T67 */
    	        mT67(ctx ); 


    	    }
    	    break;
    	case 44:
    	    // src/C.g:1:182: T68
    	    {
    	        /* 1:182: T68 */
    	        mT68(ctx ); 


    	    }
    	    break;
    	case 45:
    	    // src/C.g:1:186: T69
    	    {
    	        /* 1:186: T69 */
    	        mT69(ctx ); 


    	    }
    	    break;
    	case 46:
    	    // src/C.g:1:190: T70
    	    {
    	        /* 1:190: T70 */
    	        mT70(ctx ); 


    	    }
    	    break;
    	case 47:
    	    // src/C.g:1:194: T71
    	    {
    	        /* 1:194: T71 */
    	        mT71(ctx ); 


    	    }
    	    break;
    	case 48:
    	    // src/C.g:1:198: T72
    	    {
    	        /* 1:198: T72 */
    	        mT72(ctx ); 


    	    }
    	    break;
    	case 49:
    	    // src/C.g:1:202: T73
    	    {
    	        /* 1:202: T73 */
    	        mT73(ctx ); 


    	    }
    	    break;
    	case 50:
    	    // src/C.g:1:206: T74
    	    {
    	        /* 1:206: T74 */
    	        mT74(ctx ); 


    	    }
    	    break;
    	case 51:
    	    // src/C.g:1:210: T75
    	    {
    	        /* 1:210: T75 */
    	        mT75(ctx ); 


    	    }
    	    break;
    	case 52:
    	    // src/C.g:1:214: T76
    	    {
    	        /* 1:214: T76 */
    	        mT76(ctx ); 


    	    }
    	    break;
    	case 53:
    	    // src/C.g:1:218: T77
    	    {
    	        /* 1:218: T77 */
    	        mT77(ctx ); 


    	    }
    	    break;
    	case 54:
    	    // src/C.g:1:222: T78
    	    {
    	        /* 1:222: T78 */
    	        mT78(ctx ); 


    	    }
    	    break;
    	case 55:
    	    // src/C.g:1:226: T79
    	    {
    	        /* 1:226: T79 */
    	        mT79(ctx ); 


    	    }
    	    break;
    	case 56:
    	    // src/C.g:1:230: T80
    	    {
    	        /* 1:230: T80 */
    	        mT80(ctx ); 


    	    }
    	    break;
    	case 57:
    	    // src/C.g:1:234: T81
    	    {
    	        /* 1:234: T81 */
    	        mT81(ctx ); 


    	    }
    	    break;
    	case 58:
    	    // src/C.g:1:238: T82
    	    {
    	        /* 1:238: T82 */
    	        mT82(ctx ); 


    	    }
    	    break;
    	case 59:
    	    // src/C.g:1:242: T83
    	    {
    	        /* 1:242: T83 */
    	        mT83(ctx ); 


    	    }
    	    break;
    	case 60:
    	    // src/C.g:1:246: T84
    	    {
    	        /* 1:246: T84 */
    	        mT84(ctx ); 


    	    }
    	    break;
    	case 61:
    	    // src/C.g:1:250: T85
    	    {
    	        /* 1:250: T85 */
    	        mT85(ctx ); 


    	    }
    	    break;
    	case 62:
    	    // src/C.g:1:254: T86
    	    {
    	        /* 1:254: T86 */
    	        mT86(ctx ); 


    	    }
    	    break;
    	case 63:
    	    // src/C.g:1:258: T87
    	    {
    	        /* 1:258: T87 */
    	        mT87(ctx ); 


    	    }
    	    break;
    	case 64:
    	    // src/C.g:1:262: T88
    	    {
    	        /* 1:262: T88 */
    	        mT88(ctx ); 


    	    }
    	    break;
    	case 65:
    	    // src/C.g:1:266: T89
    	    {
    	        /* 1:266: T89 */
    	        mT89(ctx ); 


    	    }
    	    break;
    	case 66:
    	    // src/C.g:1:270: T90
    	    {
    	        /* 1:270: T90 */
    	        mT90(ctx ); 


    	    }
    	    break;
    	case 67:
    	    // src/C.g:1:274: T91
    	    {
    	        /* 1:274: T91 */
    	        mT91(ctx ); 


    	    }
    	    break;
    	case 68:
    	    // src/C.g:1:278: T92
    	    {
    	        /* 1:278: T92 */
    	        mT92(ctx ); 


    	    }
    	    break;
    	case 69:
    	    // src/C.g:1:282: T93
    	    {
    	        /* 1:282: T93 */
    	        mT93(ctx ); 


    	    }
    	    break;
    	case 70:
    	    // src/C.g:1:286: T94
    	    {
    	        /* 1:286: T94 */
    	        mT94(ctx ); 


    	    }
    	    break;
    	case 71:
    	    // src/C.g:1:290: T95
    	    {
    	        /* 1:290: T95 */
    	        mT95(ctx ); 


    	    }
    	    break;
    	case 72:
    	    // src/C.g:1:294: T96
    	    {
    	        /* 1:294: T96 */
    	        mT96(ctx ); 


    	    }
    	    break;
    	case 73:
    	    // src/C.g:1:298: T97
    	    {
    	        /* 1:298: T97 */
    	        mT97(ctx ); 


    	    }
    	    break;
    	case 74:
    	    // src/C.g:1:302: T98
    	    {
    	        /* 1:302: T98 */
    	        mT98(ctx ); 


    	    }
    	    break;
    	case 75:
    	    // src/C.g:1:306: T99
    	    {
    	        /* 1:306: T99 */
    	        mT99(ctx ); 


    	    }
    	    break;
    	case 76:
    	    // src/C.g:1:310: T100
    	    {
    	        /* 1:310: T100 */
    	        mT100(ctx ); 


    	    }
    	    break;
    	case 77:
    	    // src/C.g:1:315: T101
    	    {
    	        /* 1:315: T101 */
    	        mT101(ctx ); 


    	    }
    	    break;
    	case 78:
    	    // src/C.g:1:320: T102
    	    {
    	        /* 1:320: T102 */
    	        mT102(ctx ); 


    	    }
    	    break;
    	case 79:
    	    // src/C.g:1:325: T103
    	    {
    	        /* 1:325: T103 */
    	        mT103(ctx ); 


    	    }
    	    break;
    	case 80:
    	    // src/C.g:1:330: T104
    	    {
    	        /* 1:330: T104 */
    	        mT104(ctx ); 


    	    }
    	    break;
    	case 81:
    	    // src/C.g:1:335: T105
    	    {
    	        /* 1:335: T105 */
    	        mT105(ctx ); 


    	    }
    	    break;
    	case 82:
    	    // src/C.g:1:340: T106
    	    {
    	        /* 1:340: T106 */
    	        mT106(ctx ); 


    	    }
    	    break;
    	case 83:
    	    // src/C.g:1:345: T107
    	    {
    	        /* 1:345: T107 */
    	        mT107(ctx ); 


    	    }
    	    break;
    	case 84:
    	    // src/C.g:1:350: T108
    	    {
    	        /* 1:350: T108 */
    	        mT108(ctx ); 


    	    }
    	    break;
    	case 85:
    	    // src/C.g:1:355: T109
    	    {
    	        /* 1:355: T109 */
    	        mT109(ctx ); 


    	    }
    	    break;
    	case 86:
    	    // src/C.g:1:360: T110
    	    {
    	        /* 1:360: T110 */
    	        mT110(ctx ); 


    	    }
    	    break;
    	case 87:
    	    // src/C.g:1:365: T111
    	    {
    	        /* 1:365: T111 */
    	        mT111(ctx ); 


    	    }
    	    break;
    	case 88:
    	    // src/C.g:1:370: T112
    	    {
    	        /* 1:370: T112 */
    	        mT112(ctx ); 


    	    }
    	    break;
    	case 89:
    	    // src/C.g:1:375: T113
    	    {
    	        /* 1:375: T113 */
    	        mT113(ctx ); 


    	    }
    	    break;
    	case 90:
    	    // src/C.g:1:380: T114
    	    {
    	        /* 1:380: T114 */
    	        mT114(ctx ); 


    	    }
    	    break;
    	case 91:
    	    // src/C.g:1:385: T115
    	    {
    	        /* 1:385: T115 */
    	        mT115(ctx ); 


    	    }
    	    break;
    	case 92:
    	    // src/C.g:1:390: T116
    	    {
    	        /* 1:390: T116 */
    	        mT116(ctx ); 


    	    }
    	    break;
    	case 93:
    	    // src/C.g:1:395: T117
    	    {
    	        /* 1:395: T117 */
    	        mT117(ctx ); 


    	    }
    	    break;
    	case 94:
    	    // src/C.g:1:400: T118
    	    {
    	        /* 1:400: T118 */
    	        mT118(ctx ); 


    	    }
    	    break;
    	case 95:
    	    // src/C.g:1:405: T119
    	    {
    	        /* 1:405: T119 */
    	        mT119(ctx ); 


    	    }
    	    break;
    	case 96:
    	    // src/C.g:1:410: T120
    	    {
    	        /* 1:410: T120 */
    	        mT120(ctx ); 


    	    }
    	    break;
    	case 97:
    	    // src/C.g:1:415: T121
    	    {
    	        /* 1:415: T121 */
    	        mT121(ctx ); 


    	    }
    	    break;
    	case 98:
    	    // src/C.g:1:420: T122
    	    {
    	        /* 1:420: T122 */
    	        mT122(ctx ); 


    	    }
    	    break;
    	case 99:
    	    // src/C.g:1:425: T123
    	    {
    	        /* 1:425: T123 */
    	        mT123(ctx ); 


    	    }
    	    break;
    	case 100:
    	    // src/C.g:1:430: T124
    	    {
    	        /* 1:430: T124 */
    	        mT124(ctx ); 


    	    }
    	    break;
    	case 101:
    	    // src/C.g:1:435: T125
    	    {
    	        /* 1:435: T125 */
    	        mT125(ctx ); 


    	    }
    	    break;
    	case 102:
    	    // src/C.g:1:440: T126
    	    {
    	        /* 1:440: T126 */
    	        mT126(ctx ); 


    	    }
    	    break;
    	case 103:
    	    // src/C.g:1:445: T127
    	    {
    	        /* 1:445: T127 */
    	        mT127(ctx ); 


    	    }
    	    break;
    	case 104:
    	    // src/C.g:1:450: T128
    	    {
    	        /* 1:450: T128 */
    	        mT128(ctx ); 


    	    }
    	    break;
    	case 105:
    	    // src/C.g:1:455: T129
    	    {
    	        /* 1:455: T129 */
    	        mT129(ctx ); 


    	    }
    	    break;
    	case 106:
    	    // src/C.g:1:460: T130
    	    {
    	        /* 1:460: T130 */
    	        mT130(ctx ); 


    	    }
    	    break;
    	case 107:
    	    // src/C.g:1:465: T131
    	    {
    	        /* 1:465: T131 */
    	        mT131(ctx ); 


    	    }
    	    break;
    	case 108:
    	    // src/C.g:1:470: T132
    	    {
    	        /* 1:470: T132 */
    	        mT132(ctx ); 


    	    }
    	    break;
    	case 109:
    	    // src/C.g:1:475: T133
    	    {
    	        /* 1:475: T133 */
    	        mT133(ctx ); 


    	    }
    	    break;
    	case 110:
    	    // src/C.g:1:480: IDENTIFIER
    	    {
    	        /* 1:480: IDENTIFIER */
    	        mIDENTIFIER(ctx ); 


    	    }
    	    break;
    	case 111:
    	    // src/C.g:1:491: CHARACTER_LITERAL
    	    {
    	        /* 1:491: CHARACTER_LITERAL */
    	        mCHARACTER_LITERAL(ctx ); 


    	    }
    	    break;
    	case 112:
    	    // src/C.g:1:509: STRING_LITERAL
    	    {
    	        /* 1:509: STRING_LITERAL */
    	        mSTRING_LITERAL(ctx ); 


    	    }
    	    break;
    	case 113:
    	    // src/C.g:1:524: HEX_LITERAL
    	    {
    	        /* 1:524: HEX_LITERAL */
    	        mHEX_LITERAL(ctx ); 


    	    }
    	    break;
    	case 114:
    	    // src/C.g:1:536: DECIMAL_LITERAL
    	    {
    	        /* 1:536: DECIMAL_LITERAL */
    	        mDECIMAL_LITERAL(ctx ); 


    	    }
    	    break;
    	case 115:
    	    // src/C.g:1:552: OCTAL_LITERAL
    	    {
    	        /* 1:552: OCTAL_LITERAL */
    	        mOCTAL_LITERAL(ctx ); 


    	    }
    	    break;
    	case 116:
    	    // src/C.g:1:566: FLOATING_POINT_LITERAL
    	    {
    	        /* 1:566: FLOATING_POINT_LITERAL */
    	        mFLOATING_POINT_LITERAL(ctx ); 


    	    }
    	    break;
    	case 117:
    	    // src/C.g:1:589: WS
    	    {
    	        /* 1:589: WS */
    	        mWS(ctx ); 


    	    }
    	    break;
    	case 118:
    	    // src/C.g:1:592: COMMENT
    	    {
    	        /* 1:592: COMMENT */
    	        mCOMMENT(ctx ); 


    	    }
    	    break;
    	case 119:
    	    // src/C.g:1:600: LINE_COMMENT
    	    {
    	        /* 1:600: LINE_COMMENT */
    	        mLINE_COMMENT(ctx ); 


    	    }
    	    break;
    	case 120:
    	    // src/C.g:1:613: LINE_COMMAND
    	    {
    	        /* 1:613: LINE_COMMAND */
    	        mLINE_COMMAND(ctx ); 


    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
